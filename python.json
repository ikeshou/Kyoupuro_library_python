{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"AC_snippets": {
		"prefix": "kyoupuro",
		"body": [
			"#!/usr/bin/env python3",
			"",
			"import sys",
			"# import time",
			"# import math",
			"# import numpy as np",
			"# import scipy.sparse.csgraph as cs            # csgraph_from_dense(ndarray, null_value=inf), bellman_ford(G, return_predecessors=True), dijkstra, floyd_warshall",
			"# import random                                # random, uniform, randint, randrange, shuffle, sample",			
			"# import string                                # ascii_lowercase, ascii_uppercase, ascii_letters, digits, hexdigits",
			"# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)",
			"# from bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).",		
			"# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()",
			"# from collections import defaultdict          # subclass of dict. defaultdict(facroty)",
			"# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)",
			"# from datetime import date, datetime          # date.today(), date(year,month,day) => date obj; datetime.now(), datetime(year,month,day,hour,second,microsecond) => datetime obj; subtraction => timedelta obj",
			"# from datetime.datetime import strptime       # strptime('2019/01/01 10:05:20', '%Y/%m/%d/ %H:%M:%S') returns datetime obj",
			"# from datetime import timedelta               # td.days, td.seconds, td.microseconds, td.total_seconds(). abs function is also available.",
			"# from copy import copy, deepcopy              # use deepcopy to copy multi-dimentional matrix without reference",
			"# from functools import reduce                 # reduce(f, iter[, init])",
			"# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict (e.g. list is not allowed)",			
			"# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).",
			"# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).",
			"# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])",
			"# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]",
			"# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]",
			"# from itertools import product, permutations  # product(iter, repeat=n), permutations(iter[,r])",
			"# from itertools import combinations, combinations_with_replacement",
			"# from itertools import accumulate             # accumulate(iter[, f])",
			"# from operator import itemgetter              # itemgetter(1), itemgetter('key')",			
			"# from fractions import gcd                    # for Python 3.4 (previous contest @AtCoder)",
			"",
			"",
			"",
			"def main():",
				"\tmod = 1000000007                # 10^9+7",
				"\tinf = float('inf')              # sys.float_info.max = 1.79...e+308",
				"\t# inf = 2 ** 64 - 1             # (for fast JIT compile in PyPy) 1.84...e+19",
				"\tsys.setrecursionlimit(10**6)    # 1000 -> 1000000",
				"\tdef input(): return sys.stdin.readline().rstrip()",
				"\tdef ii():    return int(input())",
				"\tdef mi():    return map(int, input().split())",
				"\tdef mi_0():  return map(lambda x: int(x)-1, input().split())",
				"\tdef lmi():   return list(map(int, input().split()))",
				"\tdef lmi_0(): return list(map(lambda x: int(x)-1, input().split()))",
				"\tdef li():    return list(input())",
				"\t",
				"\t",
				"\t${1:#code}",
			"",
			"",
			"if __name__ == \"__main__\":",
				"\tmain()",
			"",
		],
		"description": "Python3 template for programming competition"
	},
	"STL algorithms 1 nth_element": {
		"prefix": "nth_element_snippet",
		"body": [
			"def nth_element(L, k, begin=None, end=None):",
				"\t'''",
				"\tpivot = L[k] とする。 'pivot 未満の要素 ... pivot ... pivot 以上の要素' となるよう L を破壊的に並び替える。(O(n))",
				"\t最後に基準値の pivot がおさまった場所のインデックスを返す。",
				"\tbegin <= k <= end の要請はあるが、begin, end の指定により L[begin:end+1] に対象を絞り L[k] 未満 / 以上に並べ替えることもできる。",
			"",
				"\t>>> seq = [1, 9, 2, 7, 5, 6, 4, 8, 3, 0]",
				"\t>>> nth_element(seq, 4)",
				"\t5",
				"\t>>> print(seq)",
				"\t[1, 2, 0, 4, 3, 5, 7, 8, 9, 6]",
				"\t>>> nth_element(seq, 3, begin=3, end=6)",
				"\t4",
				"\t>>> print(seq)",
				"\t[1, 2, 0, 3, 4, 5, 7, 8, 9, 6]",
			"",
				"\tArgs:",
					"\t\tL (list)",
					"\t\tk (int): 0 origin",
				"\tReturns:",
					"\t\tint: ",
				"\t'''",
				"\tn = len(L)",
				"\tif begin is None and end is None:",
					"\t\tbegin = 0",
					"\t\tend = n - 1",
				"\tif not begin <= k <= end:",
					"\t\traise RuntimeError(f'nth_element(): some bugs in indexing. k={k}, begin={begin}, end={end}.')",
			"",
				"\tpivot = L[k]",
				"\tL[k], L[end] = L[end], L[k]",
				"\t# i: 確定済みのバッファ先頭。ループ開始時点で pivot 未満であると判明しているところの先端を指す。",
				"\ti = begin - 1",
				"\t# j: 斥候。ループ開始時にここより前は検査済となっている。",
				"\t# begin ... end - 1 を動けば良い。(end は最初の swap の結果 pivot 自身がいるため探索しなくて良い)",
				"\tfor j in range(begin, end):",
					"\t\tif L[j] < pivot:",
						"\t\t\ti += 1",
						"\t\t\tL[j], L[i] = L[i], L[j]",
				"\tL[i+1], L[end] = L[end], L[i+1]",
				"\treturn i+1"
		],
		"description": "pseudo STL nth_element function"
	},
	"STL algorithms 2 ith_order_statitic": {
		"prefix": "ith_order_statistic_snippet",
		"body": [
			"def nth_element(L, k, begin=None, end=None):",
				"\t'''",
				"\tpivot = L[k] とする。 'pivot 未満の要素 ... pivot ... pivot 以上の要素' となるよう L を破壊的に並び替える。(O(n))",
				"\t最後に基準値の pivot がおさまった場所のインデックスを返す。",
				"\tbegin <= k <= end の要請はあるが、begin, end の指定により L[begin:end+1] に対象を絞り L[k] 未満 / 以上に並べ替えることもできる。",
			"",
				"\t>>> seq = [1, 9, 2, 7, 5, 6, 4, 8, 3, 0]",
				"\t>>> nth_element(seq, 4)",
				"\t5",
				"\t>>> print(seq)",
				"\t[1, 2, 0, 4, 3, 5, 7, 8, 9, 6]",
				"\t>>> nth_element(seq, 3, begin=3, end=6)",
				"\t4",
				"\t>>> print(seq)",
				"\t[1, 2, 0, 3, 4, 5, 7, 8, 9, 6]",
			"",
				"\tArgs:",
					"\t\tL (list)",
					"\t\tk (int): 0 origin",
				"\tReturns:",
					"\t\tint: ",
				"\t'''",
				"\tn = len(L)",
				"\tif begin is None and end is None:",
					"\t\tbegin = 0",
					"\t\tend = n - 1",
				"\tif not begin <= k <= end:",
					"\t\traise RuntimeError(f'nth_element(): some bugs in indexing. k={k}, begin={begin}, end={end}.')",
			"",
				"\tpivot = L[k]",
				"\tL[k], L[end] = L[end], L[k]",
				"\t# i: 確定済みのバッファ先頭。ループ開始時点で pivot 未満であると判明しているところの先端を指す。",
				"\ti = begin - 1",
				"\t# j: 斥候。ループ開始時にここより前は検査済となっている。",
				"\t# begin ... end - 1 を動けば良い。(end は最初の swap の結果 pivot 自身がいるため探索しなくて良い)",
				"\tfor j in range(begin, end):",
					"\t\tif L[j] < pivot:",
						"\t\t\ti += 1",
						"\t\t\tL[j], L[i] = L[i], L[j]",
				"\tL[i+1], L[end] = L[end], L[i+1]",
				"\treturn i+1",
			"",
			"",
			"def ith_order_statistic(L, i, begin=None, end=None):",
				"\t'''",
				"\tnth_element を用いて O(n) で L の i 番目の順序統計量を求める (1 <= i <= n)",
				"\tbegin, end は i 番目の順序統計量の候補が存在する範囲である。",
			"",
				"\t>>> seq = [1, 9, 2, 7, 5, 6, 4, 8, 3, 0]",
				"\t>>> ith_order_statistic(seq, 1) == sorted(seq)[0]",
				"\tTrue",
				"\t>>> ith_order_statistic(seq, 5) == sorted(seq)[4]",
				"\tTrue",
				"\t'''",
				"\timport random",
			"",
				"\tif begin is None and end is None:",
					"\t\tbegin = 0",
					"\t\tend = len(L) - 1",
				"\tif not begin <= i - 1 <= end:",
					"\t\traise RuntimeError(f'ith_order_statistics(): some bugs in indexing. i={i}, begin={begin}, end={end}.')",
				"\tif begin == end:",
					"\t\treturn L[begin]",
				"\t",
				"\tmid = nth_element(L, random.randint(begin, end), begin, end)",
				"\tif mid == i-1:",
					"\t\treturn L[mid]",
				"\telif mid < i-1:",
					"\t\treturn ith_order_statistic(L, i, begin=mid+1, end=end)",
				"\telse:",
					"\t\treturn ith_order_statistic(L, i, begin=begin, end=mid-1)"		
		],
		"description": "ith_order_statictic"
	},
	"STL algorithms 3 stable_partition": {
		"prefix": "stable_partition_snippet",
		"body": [
			"def stable_partition(L, func):",
				"\t'''",
				"\t述語 func を True とする要素が前に、False とする要素が後ろに並ぶよう安定的かつ破壊的に L を並び替える。(O(n))",
				"\tFalse とする要素の開始インデックスを返す (存在しない場合 L の長さが返る)",
			"",
				"\t>>> seq = [1, 9, 2, 7, 5, 6, 4, 8, 3, 0]",
				"\t>>> stable_partition(seq, lambda x: x%2==0)",
				"\t5",
				"\t>>> seq",
				"\t[2, 6, 4, 8, 0, 1, 9, 7, 5, 3]",
			"",
				"\tArgs:",
					"\t\tL (list)",
				"\tReturns:",
					"\t\tNone",
				"\t'''",
				"\tt_list = []",
				"\tf_list = []",
				"\tfor elm in L:",
					"\t\tif func(elm):",
						"\t\t\tt_list.append(elm)",
					"\t\telse:",
						"\t\t\tf_list.append(elm)",
				"\tarranged = t_list + f_list",
				"\tfor i in range(len(L)):",
					"\t\tL[i] = arranged[i]",
				"\treturn len(t_list)"
		],
		"description": "pseudo STL stable_partition fucntion"
	},
	"simple quick sort": {
		"prefix": "quick_sort_snippet",
		"body": [
			"def nth_element(L, k, begin=None, end=None):",
				"\t'''",
				"\tpivot = L[k] とする。 'pivot 未満の要素 ... pivot ... pivot 以上の要素' となるよう L を破壊的に並び替える。(O(n))",
				"\t最後に基準値の pivot がおさまった場所のインデックスを返す。",
				"\tbegin <= k <= end の要請はあるが、begin, end の指定により L[begin:end+1] に対象を絞り L[k] 未満 / 以上に並べ替えることもできる。",
			"",
				"\t>>> seq = [1, 9, 2, 7, 5, 6, 4, 8, 3, 0]",
				"\t>>> nth_element(seq, 4)",
				"\t5",
				"\t>>> print(seq)",
				"\t[1, 2, 0, 4, 3, 5, 7, 8, 9, 6]",
				"\t>>> nth_element(seq, 3, begin=3, end=6)",
				"\t4",
				"\t>>> print(seq)",
				"\t[1, 2, 0, 3, 4, 5, 7, 8, 9, 6]",
			"",
				"\tArgs:",
					"\t\tL (list)",
					"\t\tk (int): 0 origin",
				"\tReturns:",
					"\t\tint: ",
				"\t'''",
				"\tn = len(L)",
				"\tif begin is None and end is None:",
					"\t\tbegin = 0",
					"\t\tend = n - 1",
				"\tif not begin <= k <= end:",
					"\t\traise RuntimeError(f'nth_element(): some bugs in indexing. k={k}, begin={begin}, end={end}.')",
			"",
				"\tpivot = L[k]",
				"\tL[k], L[end] = L[end], L[k]",
				"\t# i: 確定済みのバッファ先頭。ループ開始時点で pivot 未満であると判明しているところの先端を指す。",
				"\ti = begin - 1",
				"\t# j: 斥候。ループ開始時にここより前は検査済となっている。",
				"\t# begin ... end - 1 を動けば良い。(end は最初の swap の結果 pivot 自身がいるため探索しなくて良い)",
				"\tfor j in range(begin, end):",
					"\t\tif L[j] < pivot:",
						"\t\t\ti += 1",
						"\t\t\tL[j], L[i] = L[i], L[j]",
				"\tL[i+1], L[end] = L[end], L[i+1]",
				"\treturn i+1",
			"",
			"",
			"def simple_quick_sort(L, i, j):",
				"\t'''",
				"\tnth_element 関数を用いて L[i:j] を O(nlgn) で破壊的に不安定でクイックソートする",
				"\t",
				"\t>>> seq = [3, 5, 2, 1, 0, 3]",
				"\t>>> simple_quick_sort(seq, 0, 6)",
				"\t>>> seq",
				"\t[0, 1, 2, 3, 3, 5]",
				"\t'''",
				"\tif i + 1 >= j:",
					"\t\t# len(L[i:j]) <= 1 であり再帰の底となる",
					"\t\treturn",
				"\t# nth_element の k, begin, end はインデックスを取っていることに注意 (スライスではない)",
				"\timport random",
				"\tbegin, end = i, j - 1",
				"\tmid = nth_element(L, random.randint(begin, end), begin, end)",
				"\tsimple_quick_sort(L, i, mid)",
				"\tsimple_quick_sort(L, mid+1, j)"
		],
		"description": "quick sort using nth_element"
	},
	"modified merge sort": {
		"prefix": "merge_sort_snippet",
		"body": [
			"def modified_merge(left, right):",
				"\t'''",
				"\tソート済み配列 left, right を受け取り、 O(n) で全体のソート済み配列を生成する",
				"\tマージの過程で転倒数をメモして返す",
			"",
				"\t>>> modified_merge([1, 5, 7], [2, 3, 3])",
				"\t(6, [1, 2, 3, 3, 5, 7])",
			"",
				"\tArgs:",
					"\t\tleft (list)",
					"\t\tright (list)",
				"\tReturns:",
					"\t\tinv (int)",
					"\t\tsorted_list (list)",
				"\t'''",
				"\tsorted_list = []",
				"\ti, j, inv = 0, 0, 0",
				"\tbuf_1 = left[:] + [float('inf')]",
				"\tbuf_2 = right[:] + [float('inf')]",
				"\tfor _ in range(len(left) + len(right)):",
					"\t\tif buf_1[i] < buf_2[j]:",
						"\t\t\tsorted_list.append(buf_1[i])",
						"\t\t\ti += 1",
						"\t\t\tinv += j",
					"\t\telse:",
						"\t\t\tsorted_list.append(buf_2[j])",
						"\t\t\tj += 1",
				"\treturn inv, sorted_list",
			"",
			"",
			"def modified_merge_sort(L, i, j):",
				"\t'''",
				"\t[i, j), つまりL[i:j] を O(nlgn) で非破壊的かつ安定にマージソートする",
				"\tマージソートの過程で転倒数をメモして返す",
				"\t",
				"\t>>> modified_merge_sort([3, 5, 2, 1, 0], 0, 5)",
				"\t(9, [0, 1, 2, 3, 5])",
			"",
				"\tArgs:",
					"\t\tL (list)",
					"\t\ti (int)",
					"\t\tj (int)",
				"\tReturns:",
					"\t\tinv (int)",
					"\t\tsorted_list (list)",
				"\t'''",
				"\tif i + 1 == j:",
					"\t\t# L[i:j+1] = [L[i]]",
					"\t\treturn 0, [L[i]]",
				"\tmid = (i + j) // 2",
				"\tleft_inv_cnt, left = modified_merge_sort(L, i, mid)",
				"\tright_inv_cnt, right = modified_merge_sort(L, mid, j)",
				"\tmerge_inv_cnt, sorted_list = modified_merge(left, right)",
				"\treturn left_inv_cnt + right_inv_cnt + merge_inv_cnt, sorted_list",
			"",
			"",
			"def count_inversion(L):",
				"\t'''",
				"\tO(nlgn) で L の要素の転倒数を求める",
			"",
				"\t>>> count_inversion([1, 9, 2, 7, 5, 6, 4, 8, 3, 0])",
				"\t26",
				"\t'''",
				"\tcnt, _ = modified_merge_sort(L, 0, len(L))",
				"\treturn cnt"
		],
		"description": "merge sort and count inversion"
	},	
	"counting_sort": {
		"prefix": "counting_sort_snippet",
		"body": [
			"def counting_sort(L, k, key=lambda x: x):",
				"\t'''",
				"\tO(n + k) で L を安定的かつ非破壊的に計数ソートする",
				"\t>>> seq = [1, 3, 5, 10, 4, 6, 15, 7, 2, 0] ",
				"\t>>> counting_sort(seq, 15)    # 0 to 15",
				"\t[0, 1, 2, 3, 4, 5, 6, 7, 10, 15]",
			"",
				"\tArgs:",
					"\t\tL (list)",
					"\t\tk (int): L の要素は 0 to k であると仮定する",
				"\tReturns:",
					"\t\tlist: sorted",
				"\t'''",
				"\tn = len(L)",
				"\taccum_sum_memo = [0] * (k+1)    # 0 to k なので",
				"\tcount_sorted = [0] * n",
			"",
				"\tfor i in range(0, n):",
					"\t\taccum_sum_memo[key(L[i])] += 1",
				"\tfor i in range(1, k+1):",
					"\t\taccum_sum_memo[i] = accum_sum_memo[i-1] + accum_sum_memo[i]",
			"",
				"\tfor j in range(n-1, -1, -1):",
					"\t\tcount_sorted[accum_sum_memo[key(L[j])] - 1] = L[j]",
					"\t\taccum_sum_memo[L[j]] -= 1    # 同じ値のものが来た時、一つ前の位置におさまるように調節してやる",
			"",
				"\treturn count_sorted"			
		],
		"description": "counting_sort"
	},
	"counting_sort_destructive": {
		"prefix": "counting_sort_destructive_snippet",
		"body": [
			"def counting_sort_destructive(L, k, key=lambda x: x):",
				"\t'''",
				"\tcounting_sort() の破壊関数版",
				"\t>>> seq = [1, 3, 5, 10, 4, 6, 15, 7, 2, 0] ",
				"\t>>> counting_sort_destructive(seq, 15)    # 0 to 15",
				"\t>>> seq",
				"\t[0, 1, 2, 3, 4, 5, 6, 7, 10, 15]",
				"\t'''",
				"\tn = len(L)",
				"\taccum_sum_memo = [0] * (k+1)    # 0 to k なので",
			"",
				"\tfor i in range(0, n):",
					"\t\taccum_sum_memo[key(L[i])] += 1",
				"\tfor i in range(1, k+1):",
					"\t\taccum_sum_memo[i] = accum_sum_memo[i-1] + accum_sum_memo[i]",
				"\t",
				"\ttmp = tuple(L[:])    # 変更されてはならない！",
				"\tfor j in range(n-1, -1, -1):",
					"\t\tL[accum_sum_memo[key(tmp[j])] - 1] = tmp[j]",
					"\t\taccum_sum_memo[key(tmp[j])] -= 1    # 同じ値のものが来た時、一つ前の位置におさまるように調節してやる"
		],
		"description": "Log output to console"
	},
	"syakutori method (scanning longest intervals that satisfy the condition)": {
		"prefix": "syakutori_logest_intervals_snippet",
		"body": [
			"def scan_longest_interval_lt_eq_x(L, x):",
				"\t'''",
				"\tL = {a_i | a_i >=0} とする",
				"\ta_1...a_n のうち、区間和が x 以下であるような区間を O(n) で探索する。",
				"\t満足する区間の数と、そのうち最長の区間のサイズ、最長の区間全てのリストを返す",
			"",
				"\t>>> cnt, width, longest_intervals = scan_longest_interval_lt_eq_x([6,3,8,1,10], 12)",
				"\t>>> cnt, width, longest_intervals",
				"\t(10, 3, [(1, 4)])",
				"\t'''",
				"\tassert(all(map(lambda x:x>=0, L)))",
				"\tn = len(L)",
				"\tcnt, max_width, longest_intervals = 0, 0, []    # 満足する区間の数、そのうち最長の区間のサイズ、最長の区間全てのリストをここに保存して最後に返す",
				"\tright_end = 0",
				"\tsummation = 0",
				"\tfor left in range(0, n):",
					"\t\t# 終了時に summation は sum(L[left:right_end]) を表す。",
					"\t\t# [left, right_end) は (left を左端に固定した時の) 最長インターバルとなる。        ",
					"\t\twhile right_end < n and summation + L[right_end] <= x:",
						"\t\t\tsummation += L[right_end]",
						"\t\t\tright_end += 1",
					"\t\tsize = right_end - left",
					"\t\t# cnt への加算。[left:left] ... [left:right_end] が left を左端点とした時の条件を満たす区間である。",
					"\t\tcnt += size",
					"\t\t# max_width, logest_intervals のメモ",
					"\t\tif max_width < size:",
						"\t\t\tmax_width = size",
						"\t\t\tlongest_intervals = [(left, right_end)]",
					"\t\telif max_width == size:",
						"\t\t\tlongest_intervals.append((left, right_end))",
			"",
					"\t\t# 尺取りで完全に区間が潰れたら right_end も動かす",
					"\t\tif right_end == left:",
						"\t\t\tright_end += 1",
					"\t\telse:",
						"\t\t\tsummation -= L[left]",
				"\treturn cnt, max_width, longest_intervals"
		],
		"description": "scanning longest intervals that satisfy the condition"
	},
	"syakutori method (scanning sortest intervals that satisfy the condition)": {
		"prefix": "syakutori_shortest_intervals_snippet",
		"body": [
			"def scan_shortest_intervals_gt_eq_x(L, x):",
				"\t'''",
				"\tL = {a_i | a_i >=0} とする",
				"\ta_1...a_n のうち、区間和が x 以上であるような区間を O(n) で探索する。",
				"\t満足する区間の数と、そのうち最短の区間の区間長、最短の区間全てのリストを返す",
			"",
				"\t>>> cnt, width, shortest_intervals = scan_shortest_intervals_gt_eq_x([6,3,8,1,10], 11)",
				"\t>>> cnt, width, shortest_intervals",
				"\t(8, 2, [(1, 3), (3, 5)])",
				"\t'''",
				"\tassert(all(map(lambda x:x>=0, L)))",
				"\tn = len(L)",
				"\tcnt, min_width, shortest_intervals = 0, float('inf'), []    # 満足する区間の数、そのうち最短の区間のサイズ、最短の区間全てのリストをここに保存して最後に返す",
				"\tsummation = 0",
				"\tright_start = 0",
				"\tfor left in range(n):",
					"\t\twhile right_start < n and summation < x:",
						"\t\t\tsummation += L[right_start]",
						"\t\t\tright_start += 1",
					"\t\t# 終了時に summation は sum(a[left:right_start]) を表す。",
					"\t\t# [left, right_start) は (left を左端に固定した時の) 最短インターバル 'とは限らない'。満たすものが発見できずに末尾までくるパターンがある。",
					"\t\t# これは sum < x で判定可能。(right_start が末尾かどうかで判定してはダメ。summation < x => 末尾は真だけれど...)",
					"\t\tif summation < x:    # これ以上 left を進めても満たす区間は存在しない",
						"\t\t\tbreak",
					"\t\tsize = right_start - left",
					"\t\t# cnt への加算。上述の break 判定により必ず L[left:right_start] ... L[left:n] が left を左端点とした時の条件を満たす区間である",
					"\t\tcnt += n - right_start + 1",
					"\t\t# min_width, shortest_intervals のメモ",
					"\t\tif min_width > size:",
						"\t\t\tmin_width = size",
						"\t\t\tshortest_intervals = [(left, right_start)]",
					"\t\telif min_width == size:",
						"\t\t\tshortest_intervals.append((left, right_start))",
			"",
					"\t\t# 尺取りで完全に区間が潰れたら right_end も動かす",
					"\t\tif right_start == left:",
						"\t\t\tright_start += 1",
					"\t\telse:",
						"\t\t\tsummation -= L[left]",
				"\treturn cnt, min_width, shortest_intervals"
		],
		"description": "scanning sortest intervals that satisfy the condition"
	},
	"sliding window": {
		"prefix": "sliding_window_snippet",
		"body": [
			"from collections import deque",
			"def sliding_minimum_query(L, k):",
				"\t'''",
				"\t長さ n の数列 L に対し、L[i:i+k] (0<=i<=n-k) の最小値を並べたリストを O(n) で求める。(ナイーブに比較すると O(nk), セグ木だと O(nlgn))",
			"",
				"\tdeque Q を用意する。",
				"\tQ にはむこう k 個の数列の要素のうち、最小要素, 2 番目の順序統計量, 3 番目の順序統計量... と順に 'もとの並び順を尊重して' 限界まで取っていった時のインデックスが保存されているとする。 ",
				"\t(入るインデックスもその指し示す値も広義単調増加)",
				"\t当然 Q の先頭がこのクエリの答えとなる。",
				"\tArgs:",
					"\t\tL (list): 正の数列",
					"\t\tk (int)",
				"\tReturns:",
					"\t\tlist: L の各要素を先頭とする k 部分列を考え、その最小値を対応する要素に記録したリスト",
				"\t'''",
				"\tn = len(L)",
				"\tif k > n:",
					"\t\traise IndexError(f'window size is greater than the length of sequence. got sequence: {L}, window size: {k}')",
				"\tif n == 0:",
					"\t\treturn []",
				"\t# ans[i] には L[i:i+k] の最小値が保存される",
				"\tans = []",
				"\t# 最初の Q (の直前まで、L[0:k-1]に対する処理) を作成しておく",
				"\tQ = deque()",
				"\tfor j in range(k-1):",
					"\t\twhile Q and L[Q[-1]] >= L[j]:",
						"\t\t\tQ.pop()",
					"\t\tQ.append(j)",
				"\t# L[0:k] に対する処理、つまり L[k-1] を読みに行くところからスタートする",
				"\tfor j in range(k-1, n):",
					"\t\ti = j - k + 1",
					"\t\twhile Q and L[Q[-1]] >= L[j]:",
						"\t\t\tQ.pop()",
					"\t\tQ.append(j)",
					"\t\tif Q[0] < i:",
						"\t\t\tQ.popleft()",
					"\t\tans.append(L[Q[0]])",
				"\treturn ans"
		],
		"description": "query to k-consective subarray"
	},
	"one dimentional coordinate compression (一次元座標圧縮)": {
		"prefix": "zaatsu_1D_snippet",
		"body": [
			"def one_dim_zaatsu_order(L):",
				"\t'''",
				"\t大小関係のみを保持する形で座標圧縮する (O(nlgn))",
			"",
				"\t>>> new_n, com, decom = one_dim_zaatsu_order([0, 1, 2, 10**3, 10**5, 4])",
				"\t>>> new_n",
				"\t6",
				"\t>>> com",
				"\t{0: 0, 1: 1, 2: 2, 4: 3, 1000: 4, 100000: 5}",
				"\t>>> decom",
				"\t{0: 0, 1: 1, 2: 2, 3: 4, 4: 1000, 5: 100000}",
			"",
				"\tXXX.X......X......X......",
				"\tが",
				"\tXXXXXX",
				"\tへと圧縮される    ",
			"",
				"\tArgs:",
					"\t\tL (list): 圧縮したい数列",
				"\tReturns:",
					"\t\tnew_n (int): 圧縮後の長さ",
					"\t\tcompress (dict): 数列の値 -> 圧縮後の番号の辞書",
					"\t\tdecompress (dict): 圧縮後の番号 -> 数列の値の辞書",
				"\t'''",
				"\tcompress, decompress = dict(), dict()",
				"\tarranged = sorted(set(L))",
				"\tfor i, elm in enumerate(arranged):",
					"\t\tcompress[elm] = i",
					"\t\tdecompress[i] = elm",
				"\treturn len(arranged), compress, decompress",
			"",
			"",
			"def one_dim_zaatsu_region(L, left, right):",
				"\t'''",
				"\t全体領域をもとに、L の要素のない連続した空白領域の個数を保持する形で座標圧縮する (O(nlgn))",
			"",
				"\t>>> new_n, com, decom = one_dim_zaatsu_region([0, 1, 2, 10**3, 10**5, 4], left=0, right=10**6)",
				"\t>>> new_n",
				"\t10",
				"\t>>> com",
				"\t{0: 0, 1: 1, 2: 2, 4: 4, 1000: 6, 100000: 8}",
				"\t>>> decom",
				"\t{0: 0, 1: 1, 2: 2, 4: 4, 6: 1000, 8: 100000}",
				"\t",
				"\tXXX.X......X......X......",
				"\tが",
				"\tXXX.X.X.X.",
				"\tへと圧縮される",
			"",
				"\tArgs:",
					"\t\tL (list): 圧縮したい数列",
					"\t\tleft (int): 全体の領域の始点",
					"\t\tright (int): 全体の領域の終点",
				"\tReturns:",
					"\t\tnew_n (int): 圧縮後の長さ",
					"\t\tcompress (dict): 数列の値 -> 圧縮後の番号の辞書",
					"\t\tdecompress (dict): 圧縮後の番号 -> 数列の値の辞書",
				"\t'''",
				"\tcompress, decompress = dict(), dict()",
				"\t# 右側に spacer を追加しているので右端点は追加しなくて良い。左端点と各点の一つ右の点を追加する。なお、この spacer が範囲内かはチェック",
				"\tpoint_with_spacer = set([left]) | set(L) | set([elm + 1 for elm in L if elm + 1 <= right])",
				"\tpoint_set = set(L)",
				"\tfor i, elm in enumerate(sorted(point_with_spacer)):",
					"\t\tif elm in point_set:",
						"\t\t\tcompress[elm] = i",
						"\t\t\tdecompress[i] = elm",
				"\treturn len(point_with_spacer), compress, decompress"
		],
		"description": "one dim compression"
	},
	"two dimentional coordinate compression (二次元座標圧縮)": {
		"prefix": "zaatsu_2D_snippet",
		"body": [
			"class TwoDimZaatsu:",
				"\tdef __init__(self, compress_x, compress_y, decompress_x, decompress_y):",
					"\t\tself.compress_x = compress_x",
					"\t\tself.compress_y = compress_y",
					"\t\tself.decompress_x = decompress_x",
					"\t\tself.decompress_y = decompress_y",
				"\tdef compress(self, i, j):",
					"\t\treturn [self.compress_x[i], self.compress_y[j]]",
				"\tdef decompress(self, i, j):",
					"\t\treturn [self.decompress_x[i], self.decompress_y[j]]",
			"",
			"",
			"def two_dim_zaatsu_order(L):",
				"\t'''",
				"\t大小関係の身を保持する形で座標圧縮する (O(nlgn))",
			"",
				"\t>>> point_list = [(0,0), (10,20), (100,5), (1000,1000), (50,1000), (10**4,500), (10**5,10**5)]",
				"\t>>> new_x, new_y, zaatsu = two_dim_zaatsu_order(point_list)",
				"\t>>> new_x",
				"\t7",
				"\t>>> new_y",
				"\t6",
				"\t>>> zaatsu.compress_x",
				"\t{0: 0, 10: 1, 50: 2, 100: 3, 1000: 4, 10000: 5, 100000: 6}",
				"\t>>> zaatsu.compress_y",
				"\t{0: 0, 5: 1, 20: 2, 500: 3, 1000: 4, 100000: 5}",
				"\t>>> zaatsu.decompress_x",
				"\t{0: 0, 1: 10, 2: 50, 3: 100, 4: 1000, 5: 10000, 6: 100000}",
				"\t>>> zaatsu.decompress_y",
				"\t{0: 0, 1: 5, 2: 20, 3: 500, 4: 1000, 5: 100000}",
				"\t>>> zaatsu.compress(50, 1000)",
				"\t[2, 4]",
				"\t>>> tmp = [[True] * new_x for _ in range(new_y)]",
				"\t>>> for x, y in point_list: tmp[zaatsu.compress(x, y)[1]][zaatsu.compress(x, y)[0]] = False",
				"\t>>> for line in tmp: print(*list(map(lambda cell: '.' if cell else 'X', line)))",
				"\tX . . . . . .",
				"\t. . . X . . .",
				"\t. X . . . . .",
				"\t. . . . . X .",
				"\t. . X . X . .",
				"\t. . . . . . X",
			"",
				"\tのように圧縮される。元は",
				"\tX . . . . . . . . . . . . . . .",
				"\t. . . . . . . X . . . . . . . .",
				"\t. . X . . . . . . . . . . . . .",
				"\t. . . . . . . . . . . . X . . .",
				"\t. . . . X . . . . X . . . . . .",
				"\t. . . . . . . . . . . . . . . X",
			"",
				"\t完全に各行各列に X が存在するようになっていることからも (大小関係を保つ範囲で) 限界まで圧縮がなされていることがわかる。",
			"",
				"\tArgs:",
					"\t\tL (list): 圧縮したい二次元座標の数列",
				"\tReturns:",
					"\t\tnew_x (int): 圧縮後の x 座標軸上の区間長",
					"\t\tnew_y (int): 圧縮後の y 座標軸上の区間長",
					"\t\tTwoDimZaatsu: compress(i, j) により座標から圧縮後の番号のペアを、decompress(i, j) により圧縮後の番号のペアから座標を得ることができる",
				"\t'''",
				"\tcompress_x, compress_y, decompress_x, decompress_y = dict(), dict(), dict(), dict()",
				"\tL_x = sorted(set([elm[0] for elm in L]))",
				"\tL_y = sorted(set([elm[1] for elm in L]))",
				"\tfor i, elm in enumerate(L_x):",
					"\t\tcompress_x[elm] = i",
					"\t\tdecompress_x[i] = elm",
				"\tfor j, elm in enumerate(L_y):",
					"\t\tcompress_y[elm] = j",
					"\t\tdecompress_y[j] = elm",
				"\treturn len(L_x), len(L_y), TwoDimZaatsu(compress_x, compress_y, decompress_x, decompress_y)",
			"",
			"",
			"from itertools import chain",
			"def two_dim_zaatsu_region(row, col, sx, tx, sy, ty):",
				"\t'''",
				"\t全体領域 (D:{(x,y)|sx<=x<=tx, sy<=y<=ty}) をもとに、L の要素の存在しない連続した空白領域の個数を保持する形で座標圧縮する (O(nlgn))",
			"",
				"\t>>> row = [[[0,3], [5,3]], [[0,7], [9,7]], [[5,9], [5,9]]]",
				"\t>>> col = [[[3,0], [3,9]], [[8,0], [8,4]], [[9,5], [9,9]]]",
				"\t>>> new_x, new_y, zaatsu = two_dim_zaatsu_region(row, col, 0, 9, 0, 9)",
				"\t>>> zaatsu.compress(8,4)",
				"\t[5, 2]",
				"\t>>> zaatsu.compress(5, 9)",
				"\t[3, 6]",
				"\t>>> tmp = [[True] * new_x for _ in range(new_y)]",
				"\t>>> _fill_compressed_grid_for_doctest(row, col, zaatsu, tmp)",
				"\t>>> for line in tmp: print(*list(map(lambda cell: '.' if cell else 'X', line)))",
				"\t. X . . . X .",
				"\tX X X X . X .",
				"\t. X . . . X .",
				"\t. X . . . . X",
				"\tX X X X X X X",
				"\t. X . . . . X",
				"\t. X . X . . X",
			"",
				"\tのように圧縮される。元は",
				"\t. . . X . . . . X .",
				"\t. . . X . . . . X .",
				"\t. . . X . . . . X .",
				"\tX X X X X X . . X .",
				"\t. . . X . . . . X .",
				"\t. . . X . . . . . X",
				"\t. . . X . . . . . X",
				"\tX X X X X X X X X X ",
				"\t. . . X . . . . . X",
				"\t. . . X . X . . . X",
			"",
				"\tArgs:",
					"\t\trow (list): 領域を x 軸方向に塗りつぶす線分の (始点, 終点) を記録したリスト",
					"\t\tcol (list): 領域を y 軸方向に塗りつぶす線分の (始点, 終点) を記録したリスト",
					"\t\tleft, right, up, down (int): 領域の端の点",
				"\tReturns:",
					"\t\tnew_x (int): 圧縮後の x 座標軸上の区間長",
					"\t\tnew_y (int): 圧縮後の y 座標軸上の区間長",
					"\t\tTwoDimZaatsu: compress(i, j) により座標から圧縮後の番号のペアを、decompress(i, j) により圧縮後の番号のペアから座標を得ることができる",
				"\t'''",
				"\tcompress_x, compress_y, decompress_x, decompress_y = dict(), dict(), dict(), dict()",
				"\t# 点の羅列の形に flatten し、point_set を生成",
				"\tpoint_set = set(map(tuple, sum(row, []) + sum(col, [])))",
				"\t# x_point_with_spacer について。row については start[0], end[0], end[0] + 1 (範囲内なら), col については (start[0]=)end[0], end[0] + 1 (範囲内なら) を追加したい。",
				"\t# col の start[0], end[0] などは同じ値が重複してメモられた上で set となる過程で潰されるが、すっきりするのでまとめて書いてしまっている",
				"\tx_point_with_spacer = set([sx]) | set(sum([[start[0], end[0], end[0] + 1] if end[0] + 1 <= tx else [start[0], end[0]] for start, end in chain(row, col)], []))",
				"\ty_point_with_spacer = set([sy]) | set(sum([[start[1], end[1], end[1] + 1] if end[1] + 1 <= ty else [start[1], end[1]] for start, end in chain(row, col)], []))",
				"\tL_x = sorted(x_point_with_spacer)",
				"\tL_y = sorted(y_point_with_spacer)",
				"\tfor i, x in enumerate(L_x):",
					"\t\tfor j, y in enumerate(L_y):",
						"\t\t\tif (x, y) in point_set:",
							"\t\t\t\tcompress_x[x] = i",
							"\t\t\t\tdecompress_x[i] = x",
							"\t\t\t\tcompress_y[y] = j",
							"\t\t\t\tdecompress_y[j] = y",
				"\treturn len(L_x), len(L_y), TwoDimZaatsu(compress_x, compress_y, decompress_x, decompress_y)"
		],
		"description": "two dim compression"
	},
	"LinkedList": {
		"prefix": "LinkedList_snippet",
		"body": [
			"class Cell:",
				"\tdef __init__(self, data, prev_cell=None, next_cell=None):",
					"\t\t'''",
					"\t\tArgs:",
						"\t\t\tdata (object)",
						"\t\t\tprev_cell (Cell)",
						"\t\t\tnext_cell (Cell)",
					"\t\t'''",
					"\t\tself.data = data",
					"\t\tself.previous = prev_cell",
					"\t\tself.next = next_cell",
				"\t",
				"\tdef __str__(self):",
					"\t\treturn 'Cell(' + str(self.data) + ')'",
					"\t\t",
			"",
			"class LinkedList:",
				"\tdef __init__(self, *args):",
					"\t\tself.head = Cell(None)",
					"\t\tself.head.previous = self.head",
					"\t\tself.head.next = self.head",
					"\t\tself.size = 0",
					"\t\tfor x in args:",
						"\t\t\tself.push_back(x)",
			"",
			"",
				"\tdef is_empty(self):",
					"\t\t'''",
					"\t\t空かどうか判定する (O(1))",
					"\t\t>>> LinkedList().is_empty()",
					"\t\tTrue",
					"\t\t>>> LinkedList(1,3,5).is_empty()",
					"\t\tFalse",
					"\t\t'''",
					"\t\treturn self.size == 0",
				"\t",
				"\tdef front(self):",
					"\t\t'''",
					"\t\t先頭のセルを返す (O(1))",
			"",
					"\t\t>>> print(LinkedList(1,3,5).front())",
					"\t\tCell(1)",
			"",
					"\t\tReturns:",
						"\t\t\tCell: front cell",
					"\t\tRaises:",
						"\t\t\tIndexError: Linked List が空の時",
					"\t\t'''",
					"\t\tif self.size == 0:",
						"\t\t\traise IndexError",
					"\t\treturn self.head.next",
			"",
				"\tdef back(self):",
					"\t\t'''",
					"\t\t末尾のセルを返す (O(1))",
			"",
					"\t\t>>> print(LinkedList(1,3,5).back())",
					"\t\tCell(5)",
			"",
					"\t\tReturns:",
						"\t\t\tCell: front cell",
					"\t\tRaises:",
						"\t\t\tIndexError: Linked List が空の時",
					"\t\t'''        ",
					"\t\tif self.size == 0:",
						"\t\t\traise IndexError",
					"\t\treturn self.head.previous",
						"\t\t\t",
				"\tdef __str__(self):",
					"\t\t'''",
					"\t\t>>> print(LinkedList(1,3,5))",
					"\t\t[1,3,5]",
					"\t\t'''",
					"\t\treturn '[' + ','.join([str(cons.data) for cons in self]) + ']'",
				"\t",
				"\tdef __len__(self):",
					"\t\t'''",
					"\t\t>>> len(LinkedList(1,3,5))",
					"\t\t3",
					"\t\t'''",
					"\t\treturn self.size",
			"",
				"\tdef __iter__(self):",
					"\t\tself.ind = self.head",
					"\t\treturn self",
			"",
				"\tdef __next__(self):",
					"\t\tself.ind = self.ind.next",
					"\t\tif self.ind is self.head:",
						"\t\t\traise StopIteration",
					"\t\treturn self.ind",
			"",
			"",
				"\tdef push_front(self, x):",
					"\t\t'''",
					"\t\t先頭にデータが x であるセルを追加 (O(1))",
			"",
					"\t\t>>> ll = LinkedList(1,3,5)",
					"\t\t>>> ll.push_front(-1)",
					"\t\t>>> print(ll)",
					"\t\t[-1,1,3,5]",
					"\t\t'''",
					"\t\tpushed_cell = Cell(x)",
					"\t\tpushed_cell.next = self.head.next",
					"\t\tpushed_cell.previous = self.head",
					"\t\tself.head.next.previous = pushed_cell",
					"\t\tself.head.next = pushed_cell",
					"\t\tself.size += 1",
			"",
				"\tdef push_back(self, x):",
					"\t\t'''",
					"\t\t末尾にデータが x であるセルを追加 (O(1))",
					"\t\t",
					"\t\t>>> ll = LinkedList(1,3,5)",
					"\t\t>>> ll.push_back(7)",
					"\t\t>>> print(ll)",
					"\t\t[1,3,5,7]",
					"\t\t'''",
					"\t\tpushed_cell = Cell(x)",
					"\t\tpushed_cell.previous = self.head.previous",
					"\t\tpushed_cell.next = self.head",
					"\t\tself.head.previous.next = pushed_cell",
					"\t\tself.head.previous = pushed_cell",
					"\t\tself.size += 1",
				"\t",
				"\tdef pop_front(self):",
					"\t\t'''",
					"\t\t先頭のセルを pop (O(1))",
			"",
					"\t\t>>> print(LinkedList(1,3,5).pop_front())",
					"\t\tCell(1)",
			"",
					"\t\tReturns:",
						"\t\t\tCell: front cell",
					"\t\tRaises:",
						"\t\t\tIndexError: Linked List が空の時",
					"\t\t'''",
					"\t\tif self.size == 0:",
						"\t\t\traise IndexError(f'LinkedList.pop_front(): cannot pop from an empty linked list.')",
					"\t\tpopped_cell = self.head.next",
					"\t\tself.head.next.next.previous = self.head",
					"\t\tself.head.next = self.head.next.next",
					"\t\tself.size -= 1",
					"\t\treturn popped_cell",
			"",
				"\tdef pop_back(self):",
					"\t\t'''",
					"\t\t末尾のセルを pop (O(1))",
			"",
					"\t\t>>> print(LinkedList(1,3,5).pop_back())",
					"\t\tCell(5)",
			"",
					"\t\tReturns:",
						"\t\t\tCell: back cell",
					"\t\tRaises:",
						"\t\t\tIndexError: Linked List が空の時",
					"\t\t'''",
					"\t\tif self.size == 0:",
						"\t\t\traise IndexError(f'LinkedList.pop_back(): cannot pop from an empty linked list.')",
					"\t\tpopped_cell = self.head.previous",
					"\t\tself.head.previous.previous.next = self.head",
					"\t\tself.head.previous = self.head.previous.previous",
					"\t\tself.size -= 1",
					"\t\treturn popped_cell",
				"\t",
			"",
				"\tdef insert_previous_by_reference(self, target_cell, x):",
					"\t\t'''",
					"\t\tLinked List の中のあるセルへの参照を受け取り、その直前にデータが x であるセルを新たに挿入する (O(1))",
			"",
					"\t\t>>> ll = LinkedList(1,3,5)",
					"\t\t>>> print(ll.insert_previous_by_reference(ll.nth(1), 2))",
					"\t\tCell(2)",
					"\t\t>>> print(ll)",
					"\t\t[1,2,3,5]",
			"",
					"\t\tArgs:",
						"\t\t\ttarget_cell (Cell)",
						"\t\t\tx (object)",
					"\t\tReturns:",
						"\t\t\tCell: 挿入されたセル        ",
					"\t\t'''",
					"\t\tinserted_cell = Cell(x, prev_cell=target_cell.previous, next_cell=target_cell)",
					"\t\tinserted_cell.previous.next = inserted_cell",
					"\t\tinserted_cell.next.previous = inserted_cell",
					"\t\tself.size += 1",
					"\t\treturn inserted_cell",
			"",
				"\tdef insert_next_by_reference(self, target_cell, x):",
					"\t\t'''",
					"\t\tLinked List の中のあるセルへの参照を受け取り、その直後にデータが x であるセルを新たに挿入する (O(1))",
			"",
					"\t\t>>> ll = LinkedList(1,3,5)",
					"\t\t>>> print(ll.insert_next_by_reference(ll.nth(1), 2))",
					"\t\tCell(2)",
					"\t\t>>> print(ll)",
					"\t\t[1,3,2,5]",
				"\t",
					"\t\tArgs:",
						"\t\t\ttarget_cell (Cell)",
						"\t\t\tx (object)",
					"\t\tReturns:",
						"\t\t\tCell: 挿入されたセル",
					"\t\t'''",
					"\t\tinserted_cell = Cell(x, prev_cell=target_cell, next_cell=target_cell.next)",
					"\t\tinserted_cell.previous.next = inserted_cell",
					"\t\tinserted_cell.next.previous = inserted_cell",
					"\t\tself.size += 1",
					"\t\treturn inserted_cell",
			"",
				"\tdef nth(self, ind):",
					"\t\t'''",
					"\t\tLinked List の中で ind 番目 (0-index) であるセルを探索して返す (O(ind))",
			"",
					"\t\t>>> print(LinkedList(1,3,5).nth(-1))",
					"\t\tCell(5)",
					"\t\t>>> print(LinkedList(1,3,5).nth(2))",
					"\t\tCell(5)",
			"",
					"\t\tArgs:",
						"\t\t\tind (int): 負数も可",
					"\t\tReturns:",
						"\t\t\tCell",
					"\t\tRaises:",
						"\t\t\tIndexError: index out of range のとき",
					"\t\t'''",
					"\t\tif ind < -self.size or self.size-1 < ind:",
						"\t\t\traise IndexError(f'LinkedList.nth(): index out of range. got f{ind} (size={self.size})')",
					"\t\tif ind < 0:",
						"\t\t\tind += self.size",
					"\t\ttmp = self.head.next",
					"\t\tfor _ in range(ind):",
						"\t\t\ttmp = tmp.next",
					"\t\treturn tmp",
			"",
				"\tdef insert_by_index(self, ind, x):",
					"\t\t'''",
					"\t\tind (0-index) の位置にデータが x であるようなセルが存在するようにセルが新たに挿入される (O(ind))",
			"",
					"\t\t>>> ll = LinkedList(1000)",
					"\t\t>>> print(ll.insert_by_index(0, 100))",
					"\t\tCell(100)",
					"\t\t>>> print(ll)",
					"\t\t[100,1000]",
			"",
					"\t\tArgs:",
						"\t\t\tind (int)",
						"\t\t\tx (object)",
					"\t\tReturns:",
						"\t\t\tCell: 挿入されたセル",
					"\t\t'''",
					"\t\treturn self.insert_previous_by_reference(self.nth(ind), x)",
			"",
			"",
				"\tdef delete(self, target_cell):",
					"\t\t'''",
					"\t\tLinked List の中のあるセルへの参照を受け取り、そのセルを削除する (O(1))",
					"\t\t",
					"\t\t>>> ll = LinkedList(1,3,5)",
					"\t\t>>> ll.delete(ll.nth(1))",
					"\t\t>>> print(ll)",
					"\t\t[1,5]",
					"\t\t",
					"\t\tArgs:",
						"\t\t\ttarget_cell (Cell)",
					"\t\t'''",
					"\t\ttarget_cell.previous.next = target_cell.next",
					"\t\ttarget_cell.next.previous = target_cell.previous",
					"\t\tself.size -= 1",
				"\t",
			"",
				"\tdef rotate(self, k=1):",
					"\t\t'''",
					"\t\t順方向、反時計回りに回転する (O(k))",
					"\t\t番兵を使う Linked List の実装だと、(self.head が直接先頭セルへのポインタを持つ実装と比べて) 少し作業が必要",
					"\t\t",
					"\t\t>>> ll = LinkedList(1,3,5)",
					"\t\t>>> ll.rotate()",
					"\t\t>>> print(ll)",
					"\t\t[3,5,1]",
					"\t\t'''",
					"\t\tif self.size > 0:",
						"\t\t\tfor _ in range(k):",
							"\t\t\t\tnext_cell = self.head.next",
							"\t\t\t\tself.delete(self.head)",
							"\t\t\t\tself.head = self.insert_next_by_reference(next_cell, None)",
				"\t",
				"\tdef reverse_rotate(self, k=1):",
					"\t\t'''",
					"\t\t逆方向、時計回りに回転する (O(k))",
					"\t\t番兵を使う Linked List の実装だと、(self.head が直接先頭セルへのポインタを持つ実装と比べて) 少し作業が必要",
			"",
					"\t\t>>> ll = LinkedList(1,3,5)",
					"\t\t>>> ll.reverse_rotate()",
					"\t\t>>> print(ll)",
					"\t\t[5,1,3]",
					"\t\t'''",
					"\t\tif self.size > 0:",
						"\t\t\tfor _ in range(k):",
							"\t\t\t\tprev_cell = self.head.previous",
							"\t\t\t\tself.delete(self.head)",
							"\t\t\t\tself.head = self.insert_previous_by_reference(prev_cell, None)",
				"\t",
			"",
				"\tdef count(self, val, key=lambda x: x):",
					"\t\t'''",
					"\t\tdata が key(val) と一致するようなセルの数を数えて返す (O(n))",
					"\t\t>>> LinkedList(1,3,5,7,9).count(True, key=lambda x: x>=5)",
					"\t\t3",
					"\t\t'''",
					"\t\tcnt = 0",
					"\t\tfor cons in self:",
						"\t\t\tif key(cons.data) == val:",
							"\t\t\t\tcnt += 1",
					"\t\treturn cnt",
			"",
				"\tdef find(self, val, key=lambda x: x):",
					"\t\t'''",
					"\t\tdata が key(val) と一致するようなセルを探索し、発見したらそのセルを返す。発見できなかったら -1 を返す",
			"",
					"\t\t>>> print(LinkedList(1,2,3,4,5).find(2))",
					"\t\tCell(2)",
					"\t\t'''",
					"\t\tfor cons in self:",
						"\t\t\tif key(cons.data) == val:",
							"\t\t\t\treturn cons",
					"\t\treturn -1"
		],
		"description": "LinkedList"
	},
	"Red Black Tree": {
		"prefix": "RedBlackTree_snippet",
		"body": [
			"BLACK = True",
			"RED = False",
			"",
			"",
			"class Vertex:",
				"\tdef __init__(self, val, color, parent=None, left=None, right=None):",
					"\t\tself.val = val",
					"\t\tself.col = color",
					"\t\tself.p = parent",
					"\t\tself.l = left",
					"\t\tself.r = right",
			"",
			"",
			"class RedBlcakTree:",
				"\tdef __init__(self):",
					"\t\tself.nil = Vertex(None, BLACK, None, None, None)    # 番兵の設定。色は必ず黒、それ以外は適当 (フィールドが一時的に使われることはあるが意味はない)",
					"\t\tself.root = self.nil",
					"\t\tself.size = 0",
				"\t",
			"",
				"\t# =========",
				"\t# 巡回、出力",
				"\t# =========",
				"\tdef inorder_traverse(self, node=None):",
					"\t\tbuf = []",
					"\t\tnode = self.root if node is None else node",
					"\t\t# print(node.val)",
					"\t\tif node != self.nil:",
						"\t\t\tbuf += self.inorder_traverse(node.l)",
						"\t\t\tbuf.append(node.val)",
						"\t\t\tbuf += self.inorder_traverse(node.r)",
					"\t\treturn buf",
				"\t",
				"\tdef preorder_traverse(self, node=None):",
					"\t\tbuf = []",
					"\t\tnode = self.root if node is None else node",
					"\t\tif node != self.nil:",
						"\t\t\tbuf.append(node.val)",
						"\t\t\tbuf += self.preorder_traverse(node.l)",
						"\t\t\tbuf += self.preorder_traverse(node.r)",
					"\t\treturn buf",
			"",
				"\tdef postorder_traverse(self, node=None):",
					"\t\tbuf = []",
					"\t\tnode = self.root if node is None else node",
					"\t\tif node != self.nil:",
						"\t\t\tbuf += self.postorder_traverse(node.l)",
						"\t\t\tbuf += self.postorder_traverse(node.r)",
						"\t\t\tbuf.append(node.val)",
					"\t\treturn buf",
				"\t",
				"\tdef __str__(self):",
					"\t\treturn '[' + ', '.join(map(str, self.inorder_traverse())) + ']'",
				"\t",
				"\tdef __len__(self):",
					"\t\treturn self.size",
			"",
				"\t",
				"\t# ===========",
				"\t# 基本的な探索",
				"\t# ===========",
				"\tdef find(self, x, node=None, key=lambda x: x):",
					"\t\t'''",
					"\t\tある部分木のなかで key(val) が x と一致するようなノードを探索する。",
					"\t\t発見したらそのノードを返し、発見できなったら -1 を返す。 (O(lgn))",
					"\t\tArgs:",
						"\t\t\tx (object): 探索したい値",
						"\t\t\tnode (Vertex): 探索を行う部分木の根。デフォルトでは探索木全体の根のノードを指す。",
						"\t\t\tkey (function)",
					"\t\t'''",
					"\t\tnode = self.root if node is None else node",
					"\t\twhile node != self.nil and key(node.val) != x:",
						"\t\t\tnode = node.l if x < node.val else node.r",
					"\t\tif node == self.nil:",
						"\t\t\treturn -1",
					"\t\telse:",
						"\t\t\treturn node",
				"\t",
				"\tdef min_node(self, node=None):",
					"\t\t'''",
					"\t\tある部分木のなかで最小のノードを探す (O(lgn))",
					"\t\t'''",
					"\t\tnode = self.root if node is None else node",
					"\t\twhile node.l != self.nil:",
						"\t\t\tnode = node.l",
					"\t\treturn node",
				"\t",
				"\tdef max_node(self, node=None):",
					"\t\t'''",
					"\t\tある部分木のなかで最大のノードを探す (O(lgn))",
					"\t\t'''",
					"\t\tnode = self.root if node is None else node",
					"\t\twhile node.r != self.nil:",
						"\t\t\tnode = node.r",
					"\t\treturn node",
				"\t",
				"\tdef successor(self, node):",
					"\t\t'''",
					"\t\t中間順木巡回で定まる順序において、ある節点の次節点を決定する。(O(lgn))",
					"\t\t次節点が存在したらそのノードを、存在しなかったら ValueError を返す。",
					"\t\t'''",
					"\t\targ = node",
					"\t\tif node.r != self.nil:",
						"\t\t\treturn self.min_node(node.r)",
					"\t\telse:",
						"\t\t\twhile node.p != self.nil and node.p.l != node:",
							"\t\t\t\tnode = node.p",
						"\t\t\tif node.p == self.nil:",
							"\t\t\t\traise ValueError(f'RedBlackTree.successor(): {arg} is the last node.')",
						"\t\t\telse:",
							"\t\t\t\treturn node.p",
				"\t",
				"\tdef predecessor(self, node):",
					"\t\t'''",
					"\t\t中間順木巡回で定まる順序において、ある節点の前節点を決定する。(O(lgn))",
					"\t\t前節点が存在したらそのノードを、存在しなかったら ValueError を返す。",
					"\t\t'''",
					"\t\targ = node",
					"\t\tif node.l != self.nil:",
						"\t\t\treturn self.max_node(node.l)",
					"\t\telse:",
						"\t\t\twhile node.p != self.nil and node.p.r != node:",
							"\t\t\t\tnode = node.p",
						"\t\t\tif node.p == self.nil:",
							"\t\t\t\traise ValueError(f'RedBlackTree.predecessor(): {arg} is the first node.')",
						"\t\t\telse:",
							"\t\t\t\treturn node.p",
			"",
			"",
				"\t# =========================",
				"\t# 単回転、重回転処理 (補助操作)",
				"\t# =========================",
				"\tdef _left_rotate(self, node):",
					"\t\t# (O(1))",
					"\t\t# left_rotate ... node 自身を、node の右の子を回転中心として左回転させる。",
					"\t\t# right_rotate ...                左の子              右回転",
					"\t\t# 二分探索木条件を満たすよう適切に子供を付け替える。",
					"\t\t# なお回転中心である left_rotate の際の右の子、right_rotate の際の左の子は self.nil ではないとする。",
			"",
					"\t\t# アルファベットを節点、<ギリシャ文字>を木とする。節点 y 中心の回転は",
							"\t\t\t\t",
					"\t\t#         y          rRot           x",
					"\t\t#     x       <γ>    ->       <α>         y",
					"\t\t#  <α> <β>           <-                <β>  <γ>   ",
					"\t\t#                    lRot",
			"",
					"\t\t# のようになる。",
					"\t\t'''",
					"\t\tArgs:",
						"\t\t\tnode (Vertex)",
					"\t\tRaises:",
						"\t\t\tRuntimeError: node ないし回転中心の node.r が self.nil であったとき",
					"\t\t'''",
					"\t\tif node == self.nil or node.r == self.nil:",
						"\t\t\traise RuntimeError('RedBlackTree._left_rotate(): cannot rotate with NIL')",
					"\t\tpivot = node.r",
					"\t\tif node.p != self.nil:",
						"\t\t\t# 自身の親の設定",
						"\t\t\tif node.p.l == node:",
							"\t\t\t\tnode.p.l = pivot",
						"\t\t\telse:",
							"\t\t\t\tnode.p.r = pivot",
					"\t\telse:",
						"\t\t\t# root の設定",
						"\t\t\tself.root = pivot",
					"\t\t# 回転中心の左の子の設定",
					"\t\tpivot.l.p = node",
					"\t\t# 回転中心の設定、自身の設定 (ポインタが上書きされないように注意)",
					"\t\tpivot.p = node.p",
					"\t\tnode.r = pivot.l",
					"\t\tpivot.l = node",
					"\t\tnode.p = pivot",
				"\t",
				"\tdef _right_rotate(self, node):",
					"\t\tif node == self.nil or node.l == self.nil:",
						"\t\t\traise RuntimeError('RedBlackTree._right_rotate(): cannot rotate with NIL')",
					"\t\tpivot = node.l",
					"\t\tif node.p != self.nil:",
						"\t\t\t# 自身の親の設定",
						"\t\t\tif node.p.l == node:",
							"\t\t\t\tnode.p.l = pivot",
						"\t\t\telse:",
							"\t\t\t\tnode.p.r = pivot",
					"\t\telse:",
						"\t\t\t# root の設定",
						"\t\t\tself.root = pivot",
					"\t\t# 回転中心の右の子の設定",
					"\t\tpivot.r.p = node",
					"\t\t# 回転中心の設定、自身の設定 (ポインタが上書きされないように注意)",
					"\t\tpivot.p = node.p",
					"\t\tnode.l = pivot.r",
					"\t\tpivot.r = node",
					"\t\tnode.p = pivot",
				"\t",
				"\tdef _LR_rotate(self, node):",
					"\t\t# (O(1))",
					"\t\t# LR_rotate ... 自身の左の子において left_rotate を行い、そのあと自身に right_rotate を行う。なお、左の子、左の子の右の子は self.nil でないものとする。",
					"\t\t# RL_rotate ...      右           right_rotate                    left_rotate             右の子、右の子の左の子",
			"",
					"\t\t# 以下の節点 u に対し LR_rotate() を施すと",
					"\t\t#             u                                      w ",
					"\t\t#     v              <t4>         LR          v             u",
					"\t\t# <t1>   w                        ->      <t1>  <t2>    <t3> <t4>",
					"\t\t#     <t2><t3>",
					"\t\t# となる。",
			"",
					"\t\t# 以下の節点 u に対し RL_rotate() を施すと",
					"\t\t#             u                                      w",
					"\t\t#   <t1>              v           RL          u             v",
					"\t\t#                 w      <t4>     ->     <t1>  <t2>     <t3> <t4>",
					"\t\t#              <t2><t3>",
					"\t\t# となる。",
					"\t\tself._left_rotate(node.l)",
					"\t\tself._right_rotate(node)",
				"\t",
				"\tdef _RL_rotate(self, node):",
					"\t\tself._right_rotate(node.r)",
					"\t\tself._left_rotate(node)",
			"",
				"\t",
				"\t# ===================",
				"\t# 鉢植え処理 (補助操作)",
				"\t# ===================",
				"\tdef _transplant(self, u_node, v_node):",
					"\t\t'''",
					"\t\tu_node の親の子供の位置に v_node 以下の部分木がくるように、v_node 部分木を機械的に移し替える。(O(1))",
					"\t\t(u の親が v の親になるわけではない。u 節点はかつての親や子供を参照し続けることに注意。オブジェクトは生き残るのでよしなに属性を書き換えて使用できる -> delete_node())",
					"\t\tなお、この関数では二分探索木条件が保持されるかどうかなどは考慮しない。        ",
					"\t\t'''",
					"\t\t# u の親の子属性の設定",
					"\t\tif u_node.p == self.nil:",
						"\t\t\tself.root = v_node",
					"\t\telif u_node.p.l == u_node:",
						"\t\t\tu_node.p.l = v_node",
					"\t\telse:",
						"\t\t\tu_node.p.r = v_node",
					"\t\t# v の親属性の設定",
					"\t\tv_node.p = u_node.p",
				"\t",
			"",
				"\t# ========",
				"\t# 節点の挿入",
				"\t# ========",
				"\tdef insert(self, data):",
					"\t\t'''",
					"\t\t値が data であるようなノードを挿入する (O(lgn))",
					"\t\tz は挿入ノードを、y は適切な挿入位置の親ノードの位置を示すトレーラポインタである",
					"\t\t'''",
					"\t\tself.size += 1",
					"\t\tx = self.root",
					"\t\ty = self.nil",
					"\t\twhile x != self.nil:",
						"\t\t\ty = x",
						"\t\t\tx = x.l if data < x.val else x.r",
					"\t\t# 挿入ノードは赤色。親は y で子は共に番兵",
					"\t\tz = Vertex(data, RED, y, self.nil, self.nil)",
					"\t\t# z の親の子属性の設定 ",
					"\t\tif y == self.nil:",
						"\t\t\tself.root = z",
					"\t\telif data < y.val:",
						"\t\t\ty.l = z",
					"\t\telse:",
						"\t\t\ty.r = z",
					"\t\t# 二色木条件を復活",
					"\t\tself._insert_fixup(z)",
				"\t",
			"",
				"\tdef _insert_fixup(self, z):",
					"\t\t'''",
					"\t\tinsert により壊れた二色木条件を適切に復活させる。(O(1))",
					"\t\t最初は 2 4 の二色木条件が満たされていない可能性がある。",
					"\t\tループ終了時には 4 の二色木条件は必ず満たされる。",
					"\t\tそして根が赤色の二色木を緩和二色木というが、この根を黒く彩色することで他の二色機条件が壊れることはない。ただ 2 が満たされるのみ。",
			"",
					"\t\tArgs:",
						"\t\t\tz (Vertex): 挿入節点 (最初は赤色)。",
					"\t\tRaises:",
						"\t\t\tRuntimeError: なぜか二色木条件がすでに壊れている時",
					"\t\t'''",
					"\t\twhile z.p.col == RED:",
						"\t\t\tparent = z.p",
						"\t\t\tif parent.p.col == RED:",
							"\t\t\t\traise RuntimeError('RedBlackTree._insert_fixup(): color constraints broken')",
						"\t\t\tif parent.l == z:",
							"\t\t\t\t# 自分は親の左の子で、親も祖先の左の子 case 1-1",
							"\t\t\t\tif parent.p.l == parent:",
								"\t\t\t\t\tself._right_rotate(parent.p)",
							"\t\t\t\t# 自分は親の左の子で、親は祖先の右の子 case 1-2",
							"\t\t\t\telse:",
								"\t\t\t\t\tself._RL_rotate(parent.p)",
								"\t\t\t\t\tz = z.r",
						"\t\t\telse:",
							"\t\t\t\t# 自分は親の右の子で、親は祖先の左の子 case 2-1",
							"\t\t\t\tif parent.p.l == parent:",
								"\t\t\t\t\tself._LR_rotate(parent.p)",
								"\t\t\t\t\tz = z.l",
							"\t\t\t\t# 自分は親の右の子で、親も祖先の右の子 case 2-2",
							"\t\t\t\telse:",
								"\t\t\t\t\tself._left_rotate(parent.p)",
						"\t\t\tz.col = BLACK",
						"\t\t\tz = z.p",
					"\t\tself.root.col = BLACK",
				"\t",
			"",
				"\t# ========",
				"\t# 節点の削除",
				"\t# ========",
				"\tdef delete(self, node):",
					"\t\t'''",
					"\t\t赤黒木内の指定された節点を削除する。(O(lgn))",
					"\t\tnode 削除後に node がいた位置におさまる節点 x として、",
					"\t\toriginal_color_of_x は x のもとの色を、",
					"\t\ty は黒が足りていない木の根を表す。",
					"\t\t(以前 x がいた場所 (両方子供あり) or 以前 node がいた場所 (子供は高々片方のみ))",
					"\t\t'''",
					"\t\tself.size -= 1",
					"\t\tx = node",
					"\t\toriginal_color_of_x = x.col",
					"\t\t# 子供なし or 右のみ子供",
					"\t\tif node.l == self.nil:",
						"\t\t\ty = node.r    # y は transplant の結果 node が存在した位置に入る",
						"\t\t\tself._transplant(node, node.r)",
					"\t\t# 左のみ子供",
					"\t\telif node.r == self.nil:",
						"\t\t\ty = node.l    # y は transplant の結果 node が存在した位置に入る",
						"\t\t\tself._transplant(node, node.l)",
					"\t\t# 両方子供",
					"\t\t# node の位置に node の次節点を鉢植えしポインタを調整",
					"\t\telse:",
						"\t\t\tx = self.successor(node)",
						"\t\t\toriginal_color_of_x = x.col",
						"\t\t\ty = x.r    # y は  transplant の結果 x が存在した位置に入る",
						"\t\t\tif x != node.r:",
							"\t\t\t\tself._transplant(x, x.r)",
							"\t\t\t\tx.r = node.r",
							"\t\t\t\tx.r.p = x",
						"\t\t\telse:",
							"\t\t\t\ty.p = x    # これがないと適切に親を辿れない。Algorithm Intro p.246 (c) でいうと x の親ポインタを y へむけている (x, y が逆なことに注意)",
						"\t\t\tself._transplant(node, x)",
						"\t\t\tnode.l.p = x",
						"\t\t\tx.l = node.l",
						"\t\t\tx.col = node.col",
					"\t\tif original_color_of_x == BLACK:",
						"\t\t\tself._delete_fixup(y)",
				"\t",
				"\tdef _delete_fixup(self, y):",
					"\t\t'''",
					"\t\tdelete により壊れた二色木条件を適切に復活させる。(O(1))",
					"\t\t最初は 2 5 の二色木条件が満たされていない可能性がある。(要素数 3 で根が黒、両方の子供が赤であるような根を削除するようなケースで 2 が破られるよ)",
					"\t\t再帰関数処理後には 5 の二色木条件は必ず満たされる。",
					"\t\tそして根が赤色の二色木を緩和二色木というが、この根を黒く彩色することで他の二色機条件が壊れることはない。ただ 2 が満たされるのみ。",
			"",
					"\t\tArgs:",
						"\t\t\ty (Vertex): 黒の足りない部分木の根",
					"\t\t'''",
					"\t\tif y != self.root:",
						"\t\t\tparent = y.p",
						"\t\t\toriginal_color_of_p = parent.col",
						"\t\t\t# 自身が左の子",
						"\t\t\tif parent.l == y:",
							"\t\t\t\t# 兄弟が赤 case 1-1",
							"\t\t\t\tif parent.r.col == RED:",
								"\t\t\t\t\t# print('1-1')",
								"\t\t\t\t\tself._left_rotate(parent)",
								"\t\t\t\t\tparent.col = RED",
								"\t\t\t\t\tparent.p.col = BLACK",
								"\t\t\t\t\tself._delete_fixup(y)",
							"\t\t\t\t# 兄弟が黒、その兄弟の左の子は赤 case 1-2",
							"\t\t\t\telif parent.r.l.col == RED:",
								"\t\t\t\t\t# print('1-2')",
								"\t\t\t\t\tself._RL_rotate(parent)",
								"\t\t\t\t\tparent.col = BLACK",
								"\t\t\t\t\tassert(parent.p.r.col == BLACK)",
								"\t\t\t\t\t# parent.p.r.col = BLACK",
								"\t\t\t\t\tparent.p.col = original_color_of_p",
							"\t\t\t\t# 兄弟が黒、その兄弟の右の子は赤 case 1-3",
							"\t\t\t\telif parent.r.r.col == RED:",
								"\t\t\t\t\t# print('1-3')",
								"\t\t\t\t\tself._left_rotate(parent)",
								"\t\t\t\t\tparent.col = BLACK",
								"\t\t\t\t\tparent.p.r.col = BLACK",
								"\t\t\t\t\tparent.p.col = original_color_of_p",
							"\t\t\t\t# 兄弟が黒、その両方の子が黒 case 1-4",
							"\t\t\t\telse:",
								"\t\t\t\t\t# print('1-4')",
								"\t\t\t\t\tparent.col = BLACK",
								"\t\t\t\t\tparent.r.col = RED",
								"\t\t\t\t\tif original_color_of_p == BLACK:",
									"\t\t\t\t\t\tself._delete_fixup(parent)",
						"\t\t\t# 自身が右の子 (以下左右対象で同様)",
						"\t\t\telse:",
							"\t\t\t\t# 兄弟が赤 case 2-1",
							"\t\t\t\tif parent.l.col == RED:",
								"\t\t\t\t\t# print('2-1')",
								"\t\t\t\t\tself._right_rotate(parent)",
								"\t\t\t\t\tparent.col = RED",
								"\t\t\t\t\tparent.p.col = BLACK",
								"\t\t\t\t\tself._delete_fixup(y)",
							"\t\t\t\t# 兄弟が黒、その兄弟の右の子は赤 case 2-2",
							"\t\t\t\telif parent.l.r.col == RED:",
								"\t\t\t\t\t# print('2-2')",
								"\t\t\t\t\tself._LR_rotate(parent)",
								"\t\t\t\t\tparent.col = BLACK",
								"\t\t\t\t\tassert(parent.p.l.col == BLACK)",
								"\t\t\t\t\t# parent.p.l.col = BLACK",
								"\t\t\t\t\tparent.p.col = original_color_of_p",
							"\t\t\t\t# 兄弟が黒、その兄弟の左の子は赤 case 2-3",
							"\t\t\t\telif parent.l.l.col == RED:",
								"\t\t\t\t\t# print('2-3')",
								"\t\t\t\t\tself._right_rotate(parent)",
								"\t\t\t\t\tparent.col = BLACK",
								"\t\t\t\t\tparent.p.l.col = BLACK",
								"\t\t\t\t\tparent.p.col = original_color_of_p",
							"\t\t\t\t# 兄弟が黒、その両方の子が黒 case 2-4",
							"\t\t\t\telse:",
								"\t\t\t\t\t# print('2-4')",
								"\t\t\t\t\tparent.col = BLACK",
								"\t\t\t\t\tparent.l.col = RED",
								"\t\t\t\t\tif original_color_of_p == BLACK:",
									"\t\t\t\t\t\tself._delete_fixup(parent)",
					"\t\tself.root.col = BLACK"
		],
		"description": "Log output to console"
	},
	"is_prime": {
		"prefix": "prime_snippet",
		"body": [
			"import math",
			"def is_prime(num):",
				"\t'''",
				"\t>>> is_prime(1000000007)",
				"\tTrue",
				"\t'''",
				"\tassert(num >= 1)",
				"\tif num == 2:",
					"\t\treturn True",
				"\tif num == 1 or num % 2 == 0:    # 下で定数倍高速化できる",
					"\t\treturn False",
				"\ti = 3",
				"\twhile i <= int(math.sqrt(num)):",
					"\t\tif i % num == 0:",
						"\t\t\treturn False",
					"\t\ti += 2",
				"\treturn True"
		],
		"description": "Log output to console"
	},
	"Sieve of Eratosthenes": {
		"prefix": "Eratosthenes_snippet",
		"body": [
			"import math",
			"class Eratos:",
				"\tdef __init__(self, num):",
					"\t\t'''",
					"\t\tO(nlglgn) で num までの素数判定テーブルを作る",
					"\t\t>>> e = Eratos(10)",
					"\t\t>>> e.table",
					"\t\t[False, False, True, True, False, True, False, True, False, False, False]",
					"\t\t'''",
					"\t\tassert(num >= 1)",
					"\t\tself.table_max = num",
					"\t\t# self.table[i] は i が素数かどうかを示す (bool)",
					"\t\tself.table = [False if i == 0 or i == 1 else True for i in range(num+1)]",
					"\t\tfor i in range(2, int(math.sqrt(num)) + 1):",
						"\t\t\tif self.table[i]:",
							"\t\t\t\tfor j in range(i ** 2, num + 1, i):    # i**2 からスタートすることで定数倍高速化できる",
								"\t\t\t\t\tself.table[j] = False",
				"\t",
				"\tdef is_prime(self, num):",
					"\t\t'''",
					"\t\tO(1) で素数判定を行う",
					"\t\t>>> e = Eratos(100)",
					"\t\t>>> [i for i in range(1, 101) if e.is_prime(i)]",
					"\t\t[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]",
					"\t\t'''",
					"\t\tassert(num >= 1)",
					"\t\tif num > self.table_max:",
						"\t\t\traise ValueError('Eratos.is_prime(): exceed table_max({}). got {}'.format(self.table_max, num))",
					"\t\treturn self.table[num]",
				"\t",
				"\tdef prime_factorize(self, num):",
					"\t\t'''",
					"\t\tO(√n) で素因数分解を行う",
					"\t\t>>> e = Eratos(10000)",
					"\t\t>>> e.prime_factorize(6552)",
					"\t\t{2: 3, 3: 2, 7: 1, 13: 1}",
					"\t\t'''",
					"\t\tassert(num >= 1)",
					"\t\tif int(math.sqrt(num)) > self.table_max:",
						"\t\t\traise ValueError('Eratos.prime_factorize(): exceed prime table size. got {}'.format(num))",
					"\t\t# 素因数分解の結果を記録する辞書        ",
					"\t\tfactorized_dict = dict()",
					"\t\tcandidate_prime_numbers = [i for i in range(2, int(math.sqrt(num)) + 1) if self.is_prime(i)]",
					"\t\t# n について、√n 以下の素数で割り続けると最後には 1 or 素数となる",
					"\t\t# 背理法を考えれば自明 (残された数が √n より上の素数の積であると仮定。これは自明に n を超えるため矛盾)",
					"\t\tfor p in candidate_prime_numbers:",
						"\t\t\tif num == 1:    # これ以上調査は無意味",
							"\t\t\t\tbreak",
						"\t\t\tif num % p == 0:",
							"\t\t\t\tcnt = 0",
							"\t\t\t\twhile num % p == 0:",
								"\t\t\t\t\tnum //= p",
								"\t\t\t\t\tcnt += 1",
							"\t\t\t\tfactorized_dict[p] = cnt",
					"\t\tif num != 1:",
						"\t\t\tfactorized_dict[num] = 1",
					"\t\treturn factorized_dict",
				"\t",
				"\tdef enum_divisor(self, num):",
					"\t\t'''",
					"\t\tO(√n) で約数列挙を行う",
					"\t\t>>> e = Eratos(10000)",
					"\t\t>>> e.enum_divisor(4)",
					"\t\t[1, 2, 4]",
					"\t\t>>> e.enum_divisor(19)",
					"\t\t[1, 19]",
					"\t\t>>> e.enum_divisor(100)",
					"\t\t[1, 2, 4, 5, 10, 20, 25, 50, 100]",
					"\t\t'''",
					"\t\tdivisor_small = []",
					"\t\tdivisor_large = []",
					"\t\tfor i in range(1, int(math.sqrt(num)) + 1):",
						"\t\t\tif num % i == 0:",
							"\t\t\t\tdivisor_small.append(i)",
							"\t\t\t\tif i != num // i:",
								"\t\t\t\t\tdivisor_large.append(num // i)",
					"\t\tdivisor_large.reverse()",
					"\t\treturn divisor_small + divisor_large"
		],
		"description": "Eratosthenes"
	},
	"factorial (mod)": {
		"prefix": "factorial_snippet",
		"body": [
			"def make_factorial_table(size, mod):",
				"\t'''",
				"\tfact_mod[i] は i! % mod を表す。fact_mod[0] ~ facto_mod[size] まで計算可能なテーブルを返す",
				"\t>>> make_factorial_table(20, 10**9+7)",
				"\t[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 227020758, 178290591, 674358851, 789741546, 425606191, 660911389, 557316307, 146326063]",
				"\t'''",
				"\tfact_mod = [1] * (size + 1)",
				"\tfor i in range(1, size + 1):",
					"\t\tfact_mod[i] = (fact_mod[i - 1] * i) % mod",
				"\treturn fact_mod"
		],
		"description": "make factorial table (mod)"
	},
	"combination (mod)": {
		"prefix": "combination_snippet",
		"body": [
			"def combination(n, r, mod, fact_table):",
				"\t'''",
				"\tフェルマーの小定理 ",
				"\ta ^ p-1 ≡ 1 (mod p)",
				"\ta ^ p-2 ≡ 1/a (mod p) (逆元)",
				"\tnCr = (n!) / ((n-r)! * r!) だが、mod p の世界ではこの分母を逆元を用いて計算しておくことが可能",
				"\t",
				"\t>>> m = 1000000007",
				"\t>>> fact_table = make_factorial_table(100, m)",
				"\t>>> combination(10, 5, m, fact_table)",
				"\t252",
				"\t>>> combination(100, 50, m, fact_table)",
				"\t538992043",
				"\t'''",
				"\tnumerator = fact_table[n]",
				"\tdenominator = (fact_table[n-r] * fact_table[r]) % mod",
				"\t# pow はすでに繰り返し二乗法で効率的に実装されている",
				"\treturn (numerator * pow(denominator, mod-2, mod)) % mod"
		],
		"description": "nCr (mod)"
	},
	"Union Find Tree": {
		"prefix": "UnionFindTree_snipeet",
		"body": [
			"class UnionFindTree:",
				"\tdef __init__(self, num_of_elm):",
					"\t\t'''",
					"\t\t0 ... num_of_elem - 1 まで数字で表される (0-index) グループを管理する union find tree を作成する (O(n))",
					"\t\t'''",
					"\t\tself.n = num_of_elm",
					"\t\tself.table = [i for i in range(self.n)]    # table[ind] は ind の親の index を表す。ind == table[ind] の時そのグループの root である。",
					"\t\tself.rank = [0] * self.n    # root となる ind について rank[ind] はその木の深さを表す。それ以外の ind については意味を持たない。",
					"\t\tself.group_size = [1] * self.n    # root となる ind について group_size[ind] はそのグループに属するメンバの個数を表す。それ以外の ind については意味を持たない。",
				"\t",
				"\tdef _find_set(self, x):",
					"\t\t'''",
					"\t\tx の属するグループ番号を O(α(n)) で求める",
					"\t\t'''",
					"\t\tparent = self.table[x]",
					"\t\tif x == parent:",
						"\t\t\treturn x",
					"\t\telse:",
						"\t\t\troot = self._find_set(parent)",
						"\t\t\t# 経路圧縮",
						"\t\t\tself.table[x] = root",
						"\t\t\treturn root",
				"\t",
				"\tdef is_same(self, x, y):",
					"\t\t'''",
					"\t\tx と y が同じグループに属するか O(α(n)) で判定する",
					"\t\t'''",
					"\t\treturn self._find_set(x) == self._find_set(y)",
			"",
				"\tdef union(self, x, y):",
					"\t\t'''",
					"\t\tx と y の属するグループを O(α(n)) で統合する",
					"\t\t'''",
					"\t\tshallow_root = self._find_set(x)",
					"\t\tdeep_root = self._find_set(y)",
					"\t\tif self.rank[shallow_root] > self.rank[deep_root]:",
						"\t\t\tshallow_root, deep_root = deep_root, shallow_root",
					"\t\t# そもそも同一グループだった時",
					"\t\tif shallow_root == deep_root:",
						"\t\t\treturn False",
					"\t\t# グループが異なるので union",
					"\t\telse:",
						"\t\t\tself.table[shallow_root] = deep_root",
						"\t\t\tself.group_size[deep_root] += self.group_size[shallow_root]",
						"\t\t\t# 深さが等しかったときはつけ加えられた側の rank をインクリメントする",
						"\t\t\tif self.rank[shallow_root] == self.rank[deep_root]:",
							"\t\t\t\tself.rank[deep_root] += 1",
						"\t\t\treturn True",
			"",
				"\tdef akin_num(self, x):",
					"\t\t'''",
					"\t\tx の属するグループのサイズを O(1) で計算する",
					"\t\t'''",
					"\t\tx_root = self._find_set(x)",
					"\t\treturn self.group_size[x_root]",
			"",
				"\tdef print_group_id(self):",
					"\t\tprint([self._find_set(x) for x in self.table])"
		],
		"description": "Union Find Tree"
	},
	"RollingHash": {
		"prefix": "RollingHash_snippet",
		"body": [
			"from random import randint",
			"class RollingHash:",
				"\tdef __init__(self, s):",
					"\t\tself.s = s    # パターン探索を行われる側の文字列",
					"\t\tself.size = len(s)",
					"\t\tself.hashmod = 2 ** 64 - 1",
					"\t\tself.base = randint(2 ** 10, 2 ** 11)",
					"\t\tself.hash_list = self._make_rolling_hash_list()",
			"",
				"\tdef _make_rolling_hash_list(self):",
					"\t\t'''",
					"\t\t累積文字列のハッシュ値を記録したテーブルの作成を行う (O(n))",
					"\t\t'''",
					"\t\thash_list = [0] * (self.size + 1)    # [h(s[0:0]), h(s[0:1]), h(s[0:2]), h(s[0:3]), ..., h(s[0:size])]",
					"\t\tprev = 0",
					"\t\tfor i in range(1, self.size + 1):",
						"\t\t\thash_num = (prev * self.base + ord(self.s[i-1])) % self.hashmod",
						"\t\t\thash_list[i] = hash_num",
						"\t\t\tprev = hash_num",
					"\t\treturn hash_list",
			"",
				"\tdef calc_str_hash(self, pattern):",
					"\t\t'''",
					"\t\t文字列パターンのハッシュ値の計算を行う (O(L))",
					"\t\tArgs:",
						"\t\t\tpattern (str)",
					"\t\tReturns:",
						"\t\t\thash_num (int)",
					"\t\t'''",
					"\t\tlength = len(pattern)",
					"\t\thash_num = 0",
					"\t\tfor i in range(length):",
						"\t\t\thash_num = (hash_num + ord(pattern[i]) * pow(self.base, length - 1 - i, self.hashmod)) % self.hashmod",
					"\t\treturn hash_num",
				"\t",
				"\tdef calc_interval_hash(self, i, j):",
					"\t\t'''",
					"\t\ts[i:j] のハッシュ値の計算を行う (O(1))",
					"\t\tArgs:",
						"\t\t\ti (int): 左の閉区間",
						"\t\t\tj (int): 右の開区間",
					"\t\tReturns:",
						"\t\t\thash_ium (int)",
					"\t\t'''",
					"\t\treturn (self.hash_list[j] - self.hash_list[i] * pow(self.base, j - i, self.hashmod)) % self.hashmod",
				"\t",
				"\tdef match_predict_with_interval(self, hashed_pattern, i, j):",
					"\t\t'''",
					"\t\t[i,j), つまり s[i:j] が hashed_pattern と一致するかどうかを判定する (O(1))",
					"\t\tpattern ではなく hashed_pattern であることに注意。",
					"\t\tArgs:",
						"\t\t\thashed_pattern (int): self.calc_str_hash() で計算された文字列のハッシュ値",
						"\t\t\ti (int): 左の閉区間",
						"\t\t\tj (int): 右の開区間",
					"\t\tReturns:",
						"\t\t\tbool",
					"\t\t'''",
					"\t\tif i > j:",
						"\t\t\traise IndexError(f'interval should be [i, j) (i <= j). got i: {i} and j: {j}')",
					"\t\tif not isinstance(hashed_pattern, int) or not 0 <= hashed_pattern <= self.hashmod - 1:",
						"\t\t\traise ValueError(f'argument must be hashed_pattern (positive integer that is less than {self.hashmod}). got {hashed_pattern}')",
					"\t\treturn hashed_pattern == self.calc_interval_hash(i, j)",
				"\t",
				"\tdef find_all(self, target_s):",
					"\t\t'''",
					"\t\ttarget_s と一致する [i,j) つまり s[i:j] を O(n) で探索する",
			"",
					"\t\t>>> rolling = RollingHash('abcgbabcgbabcbabcagcabcabgc')",
					"\t\t>>> iter = rolling.find_all('abc')",
					"\t\t>>> print(list(iter))",
					"\t\t[(0, 3), (5, 8), (10, 13), (14, 17), (20, 23)]",
			"",
					"\t\tArgs:",
						"\t\t\ttarget_s (str): s から一致する区間を探索したいターゲットパターン",
					"\t\tReturns:",
						"\t\t\titer: マッチした全ての s[i:j] について、 (i, j) のタプルを返すようなイテレータ",
					"\t\t'''",
					"\t\tn = len(target_s)",
					"\t\thashed_target_s = self.calc_str_hash(target_s)",
					"\t\tans = []",
					"\t\tfor i in range(self.size - n + 1):",
						"\t\t\tif self.match_predict_with_interval(hashed_target_s, i, i + n):",
							"\t\t\t\tans.append((i, i+n))",
					"\t\treturn iter(ans)"
		],
		"description": "RollingHash"
	},
	"Trie Hash Tree": {
		"prefix": "TrieHashTree_snippet",
		"body": [
			"class TrieHashNode:",
				"\tdef __init__(self, data='', parent=None, terminal=False, word_count=0):",
					"\t\tself.data = data",
					"\t\tself.parent = parent    # 親ノードへの参照",
					"\t\tself.children = dict()    # 次の文字をキーとして子ノード参照を記録している",
					"\t\tself.terminal = terminal    # この文字で終了する単語が存在するか",
					"\t\tself.word_count = word_count    # このノード以下の単語数",
				"\t",
				"\tdef traverse(self):",
					"\t\t'このノード以下の全単語を巡回しリストにまとめて返す'",
					"\t\tans = [self.data] if self.terminal else []    # root の時、単語の終わりでない時は [] となって欲しい",
					"\t\tfor child in self.children.values():",
						"\t\t\tans += child.traverse()",
					"\t\treturn ans",
				"\t",
				"\tdef search_child_char(self, char):",
					"\t\t'このノードの子供に char に対応するノードが存在するならそのノードを、存在しないなら None を返す'",
					"\t\ttry:",
						"\t\t\treturn self.children[char]",
					"\t\texcept KeyError:",
						"\t\t\treturn None",
				"\t",
				"\tdef set_child_char(self, char, is_terminal):",
					"\t\t'このノードの子供に char と対応するノードを作成しそのノードを返す'",
					"\t\tchild_node = TrieHashNode(data=self.data+char, parent=self, terminal=is_terminal, word_count=1)",
					"\t\tself.children[char] = child_node",
					"\t\treturn child_node",
				"\t",
				"\tdef delete_self(self):",
					"\t\t'このノードを削除し親のノードを返す'",
					"\t\tchar = self.data[-1]",
					"\t\tparent = self.parent",
					"\t\tdel parent.children[char]",
					"\t\treturn parent",
				"\t",
				"\tdef incf_upcurrent_word_count(self):",
					"\t\t'このノードから root までの道 [self, root] 上の全てのノードの word_count を 1 増やす'",
					"\t\tcurrent = self",
					"\t\twhile current is not None:",
						"\t\t\tcurrent.word_count += 1",
						"\t\t\tcurrent = current.parent",
				"\t",
				"\tdef decf_upcurrent_word_count(self):",
					"\t\t'このノードから root までの道 [self, root] 上の全てのノードの word_count を 1 減らす'",
					"\t\tcurrent = self",
					"\t\twhile current is not None:",
						"\t\t\tcurrent.word_count -= 1",
						"\t\t\tcurrent = current.parent",
			"",
			"",
			"class TrieHashTree:",
				"\tdef __init__(self):",
					"\t\tself.root = TrieHashNode()    # 色々書き込まれることはあるがその値に意味はない",
			"",
				"\tdef traverse(self):",
					"\t\t'''",
					"\t\tトライ木の全単語を巡回しリストにまとめて返す (O(全ノード数))",
					"\t\tReturns:",
						"\t\t\tlist",
					"\t\t'''",
					"\t\treturn self.root.traverse()",
				"\t",
				"\tdef _common_prefix_node(self, prefix):",
					"\t\t'''",
					"\t\t(search_word(), search_prefix(), count_all_word_with_prefix(), find_all_word_with_prefix() で使用する内部関数)",
					"\t\tトライ木上で prefix と対応した道を探索し、終点のノードを返す。対応した道が存在しない場合 None を返す (O(単語長)) 。",
					"\t\tArgs:",
						"\t\t\tprefix (str)",
					"\t\tReturns:",
						"\t\t\tUnion(TrieHashNode, None)",
					"\t\tRaises:",
						"\t\t\tValueError: prefix が '' の時",
					"\t\t'''",
					"\t\tif prefix == '':",
						"\t\t\traise ValueError('TrieHashTree._common_prefix_node(): prefix should not be an empty string.')",
					"\t\tcurrent = self.root",
					"\t\tfor char in prefix:",
						"\t\t\tchild_node = current.search_child_char(char)",
						"\t\t\tif child_node is None:",
							"\t\t\t\treturn None",
						"\t\t\telse:",
							"\t\t\t\tcurrent = child_node",
					"\t\treturn current",
			"",
				"\tdef search_word(self, word):",
					"\t\t'''",
					"\t\tトライ木に指定した単語が存在するか判定する (O(単語長))",
					"\t\tArgs:",
						"\t\t\tword (str)",
					"\t\tReturns:",
						"\t\t\tbool",
					"\t\t'''",
					"\t\tlast = self._common_prefix_node(word)",
					"\t\tif last is None:",
						"\t\t\treturn False",
					"\t\treturn last.terminal    # 仮に word の char と対応するノードがあってもそこで単語がきれない場合は False (その単語を接頭語とする単語で登録されていた場合など)",
			"",
				"\tdef search_prefix(self, prefix):",
					"\t\t'''",
					"\t\tトライ木に指定した接頭語を持つ単語が存在するか判定する (O(接頭語長))",
					"\t\tArgs:",
						"\t\t\tword (str)",
					"\t\tReturns:",
						"\t\t\tbool",
					"\t\t'''",
					"\t\treturn self._common_prefix_node(prefix) is not None",
				"\t",
				"\tdef count_all_word_with_prefix(self, prefix):",
					"\t\t'''",
					"\t\t指定した接頭語を持つ単語の個数を返す。(存在しない場合は 0) (O(接頭語長))",
					"\t\tArgs:",
						"\t\t\tword (str)",
					"\t\tReturns:",
						"\t\t\tint",
					"\t\t'''",
					"\t\tlast = self._common_prefix_node(prefix)",
					"\t\treturn last.word_count if last is not None else 0   ",
			"",
				"\tdef find_all_word_with_prefix(self, prefix):",
					"\t\t'''",
					"\t\t指定した接頭語を持つ単語のリストを返す。(存在しない場合は []) (O(接頭語長))",
					"\t\tArgs:",
						"\t\t\tword (str)",
					"\t\tReturns:",
						"\t\t\tlist        ",
					"\t\t'''",
					"\t\tlast = self._common_prefix_node(prefix)",
					"\t\treturn last.traverse() if last is not None else []",
			"",
			"",
				"\tdef insert_word(self, word):",
					"\t\t'''",
					"\t\t指定した単語をトライ木に挿入する。(O(単語長))",
					"\t\tArgs:",
						"\t\t\tword (str)",
					"\t\t'''",
					"\t\tcurrent = self.root",
					"\t\tres = ''",
					"\t\tfor ind, char in enumerate(word):",
						"\t\t\tchild_node = current.search_child_char(char)",
						"\t\t\tif child_node is None:",
							"\t\t\t\tres = word[ind:]",
							"\t\t\t\tbreak",
						"\t\t\telse:",
							"\t\t\t\tcurrent = child_node",
					"\t\t# すでに対応するブランチは出来上がっていた場合",
					"\t\tif res == '':",
						"\t\t\t# 対応する単語が登録されていなかった場合のみ処理を行う",
						"\t\t\tif not current.terminal:",
							"\t\t\t\tcurrent.terminal = True",
							"\t\t\t\tcurrent.incf_upcurrent_word_count()",
					"\t\t# 今のノードから res に対応するブランチを作成する必要がある場合",
					"\t\telse:",
						"\t\t\tcurrent.incf_upcurrent_word_count()",
						"\t\t\tfor ind, char in enumerate(res):",
							"\t\t\t\tif ind != len(res)-1:",
								"\t\t\t\t\tcurrent = current.set_child_char(char, is_terminal=False)",
							"\t\t\t\telse:",
								"\t\t\t\t\tcurrent = current.set_child_char(char, is_terminal=True)",
			"",
			"",
				"\tdef delete_word(self, word):",
					"\t\t'''",
					"\t\t指定した単語をトライ木から削除する。(O(単語長))",
					"\t\tArgs:",
						"\t\t\tword (str)",
					"\t\tRaises:",
						"\t\t\tValueError: 指定した単語がそもそも登録されていない時",
					"\t\t'''",
					"\t\tif not self.search_word(word):",
						"\t\t\traise ValueError(f'TrieHashTree.delete_word(): {word} not in TrieHashTree')",
					"\t\tlast = self._common_prefix_node(word)",
					"\t\t# ノードを削除する必要がない場合",
					"\t\tif last.children:",
						"\t\t\tassert(last.terminal == True)",
						"\t\t\tlast.terminal = False",
						"\t\t\tlast.decf_upcurrent_word_count()",
					"\t\t# 一本鎖のうちは削除を続ける",
					"\t\telse:",
						"\t\t\tlast = last.delete_self()",
						"\t\t\twhile last != self.root and len(last.children) == 0:",
							"\t\t\t\tlast = last.delete_self()",
						"\t\t\tlast.decf_upcurrent_word_count()"
		],
		"description": "Trie Tree using dictionary"
	},
	"Bridge Detection": {
		"prefix": "bridge_snippet",
		"body": [
			"def bridge_detect(adj, start=0):",
				"\t'''",
				"\t橋を検出する (O(V+E))",
				"\tArgs:",
					"\t\tadj (list): 隣接リスト",
					"\t\tstart (int): 開始頂点を示すインデックス",
				"\tReturns:",
					"\t\tbridge (list): 橋を示すリスト。edge(u, v) が橋である時 (u, v) がこのリストに追加される。u は DFS木において v の親に当たる。 (edge(v, u) は bridge に含まれない)",
					"\t\tcycle_graph (list): cycle_graph[i] には i と '直接つながる' 二重連結成分が set で入っているリスト",
				"\t'''",
				"\tn = len(adj)",
				"\torder = [-1] * n",
				"\tlowlink = [-1] * n",
				"\tcnt = -1",
				"\tbridge = []",
				"\tcycle_graph = [set() for _ in range(n)]",
				"\tdef dfs(u, parent=-1):",
					"\t\tnonlocal cnt    # order をふる用。再起呼び出しでのインクリメントが呼び出しもとでも反映されて欲しい",
					"\t\tcnt += 1",
					"\t\torder[u] = cnt",
					"\t\tlowlink[u] = cnt",
					"\t\tfor v in adj[u]:",
						"\t\t\t# 親",
						"\t\t\tif v == parent:",
							"\t\t\t\tcontinue",
						"\t\t\t# 未訪問",
						"\t\t\tif order[v] == -1:",
							"\t\t\t\tdfs(v, parent=u)",
							"\t\t\t\tlowlink[u] = min(lowlink[u], lowlink[v])",
						"\t\t\t# v は訪問ずみだが、DFS 木の親でない。uv は後退辺",
						"\t\t\telse:",
							"\t\t\t\tlowlink[u] = min(lowlink[u], order[v])",
						"\t\t\t# bridge detection",
						"\t\t\tif order[u] < lowlink[v]:",
							"\t\t\t\tbridge.append((u, v))",
						"\t\t\t# for bi-connected components decomposition",
						"\t\t\telse:",
							"\t\t\t\tcycle_graph[u].add(v)",
							"\t\t\t\tcycle_graph[v].add(u)",
				"\tdfs(start)",
				"\treturn bridge, cycle_graph"
		],
		"description": "bridge detection"
	},
	"Articulation Point Detection": {
		"prefix": "articulation_snippet",
		"body": [
			"def articulation_detect(adj, start=0):",
				"\t'''",
				"\t関節点を検出する (O(V+E))",
				"\tArgs:",
					"\t\tadj (list): 隣接リスト",
					"\t\tstart (int): 開始頂点を示すインデックス",
				"\tReturns:",
					"\t\tarticulation (list): 関節点である頂点のリスト",
				"\t'''",
				"\tn = len(adj)",
				"\torder = [-1] * n",
				"\tlowlink = [-1] * n",
				"\tcnt = -1",
				"\tarticulation = []",
				"\tdef dfs(u, parent=-1):",
					"\t\tnonlocal cnt    # order をふる用。再起呼び出しでのインクリメントが呼び出しもとでも反映されて欲しい",
					"\t\tcnt += 1",
					"\t\torder[u] = cnt",
					"\t\tlowlink[u] = cnt",
					"\t\tfor v in adj[u]:",
						"\t\t\t# 親",
						"\t\t\tif v == parent:",
							"\t\t\t\tcontinue",
						"\t\t\t# 未訪問",
						"\t\t\tif order[v] == -1:",
							"\t\t\t\tdfs(v, parent=u)",
							"\t\t\t\tlowlink[u] = min(lowlink[u], lowlink[v])",
						"\t\t\t# v は訪問ずみだが、DFS 木の親でない。uv は後退辺",
						"\t\t\telse:",
							"\t\t\t\tlowlink[u] = min(lowlink[u], order[v])",
					"\t\t# articulation detection",
					"\t\tif u == start and len(adj[u]) > 1:",
						"\t\t\tarticulation.append(u)",
					"\t\telif any(map(lambda v: order[u] <= lowlink[v], filter(lambda x: x!=parent, adj[u]))):",
						"\t\t\tarticulation.append(u)",
				"\tdfs(start)",
				"\treturn articulation"
		],
		"description": "articulation point detection"
	},
	"Bi-connected Components Decomposition": {
		"prefix": "bi_connected_snippet",
		"body": [
			"def contract_from_cycle(bridge, cycle_graph):",
				"\t'''",
				"\t二重連結成分分解を行う (O(V+E))",
				"\tArgs:",
					"\t\tbridge (list): 橋を示すリスト。edge(u, v) が橋である時 (u, v) がこのリストに追加される",
					"\t\tcycle_graph (list): cycle_graph[i] には i と '直接つながる' 二重連結成分が set で入っているリスト",
				"\tReturns:",
					"\t\tvertex_to_group_num (list): vertex_to_group_num[i] には i がどのグループ番号で表されるグループに属するかが int で入っているリスト",
					"\t\tbi_connected (list): 二重連結成分ごとにグルーピングを行った時、そのグループ番号で表現された隣接リスト",
				"\t'''",
				"\tn = len(cycle_graph)",
				"\tvisited = [False] * n",
				"\tvertex_to_group_num = [-1] * n",
				"\tdef dfs(u, group_num):",
					"\t\t' u と同じ二重連結成分に属する頂点全てに num なるグルーピングを施す。'",
					"\t\tvisited[u] = True",
					"\t\tvertex_to_group_num[u] = group_num",
					"\t\tfor v in cycle_graph[u]:",
						"\t\t\tif not visited[v]:",
							"\t\t\t\tdfs(v, group_num)",
				"\t# 実際に二重連結成分単位でグルーピング",
				"\tcnt = -1",
				"\tfor u in range(n):",
					"\t\tif not visited[u]:",
						"\t\t\tcnt += 1",
						"\t\t\tdfs(u, cnt)",
				"\t# そのグループ番号を新たなノードだとみなしたときの隣接リストを作る",
				"\tbi_connected = [[] for _ in range(cnt + 1)]",
				"\tfor u, v in bridge:",
					"\t\tbi_connected[vertex_to_group_num[u]].append(vertex_to_group_num[v])",
					"\t\tbi_connected[vertex_to_group_num[v]].append(vertex_to_group_num[u])",
				"\treturn vertex_to_group_num, bi_connected"
		],
		"description": "bi-connected components decomposition from bridge and cycle graph"
	},
	"Strongly-connected Components Decomposition": {
		"prefix": "strongly_connected_snippet",
		"body": [
			"def scc(graph, rgraph):",
				"\t'''",
				"\tgraph, rgraph をもとに強連結成分ごとのグルーピングを行う。",
				"\tグループ番号は 0 から始まり、その順が強連結成分分解後の DAG におけるトポロジカル順序を表す。",
				"\tグループ数、グループ番号を各頂点に対し記したリストを返す。",
				"\tArgs:",
					"\t\tgraph (list): 隣接リスト",
					"\t\trgraph (list): 有向辺を逆に繋いだグラフの隣接リスト",
				"\tReturns:",
					"\t\tgroup_numbers (int): トータルのグループ (強連結成分) 数",
					"\t\tvertex_to_group_num (list): vertex_to_group_num[i] には i がどのグループ番号で表されるグループに属するかが int で入っているリスト",
				"\t'''",
				"\tn = len(graph)",
				"\torder = []",
				"\tvisited = [False] * n",
				"\tdef dfs(current=0):",
					"\t\tvisited[current] = True",
					"\t\tfor v in graph[current]:",
						"\t\t\tif not visited[v]:",
							"\t\t\t\tdfs(v)",
					"\t\torder.append(current)",
				"\tvertex_to_group_num = [0] * n",
				"\tdef rdfs(u, group_num):",
					"\t\tvisited[u] = True",
					"\t\tvertex_to_group_num[u] = group_num",
					"\t\tfor v in rgraph[u]:",
						"\t\t\tif not visited[v]:",
							"\t\t\t\trdfs(v, group_num)",
				"\t# DFS the graph and memorize the end time of visiting for each node",
				"\tfor i in range(n):",
					"\t\tif not visited[i]:",
						"\t\t\tdfs(i)",
				"\t# DFS the transposed graph",
				"\tcnt = -1",
				"\tvisited = [False] * n    # 再初期化",
				"\torder.reverse()    # 訪問終了時刻が遅いものから",
				"\tfor j in order:",
					"\t\tif not visited[j]:",
						"\t\t\tcnt += 1",
						"\t\t\trdfs(j, cnt)",
				"\t# 0 ... cnt までがグループ番号として使用されている。",
				"\treturn cnt+1, vertex_to_group_num",
						"\t\t\t",
				"\t",
			"def contract_from_group(graph, group_num, vertex_to_group_num):",
				"\t'''",
				"\tArgs:",
					"\t\tgraph (list): 隣接リスト",
					"\t\tgroup_num (int): トータルのグループ (強連結成分) 数",
					"\t\tvertex_to_group_num (list): vertex_to_group_num[i] には i がどのグループ番号で表されるグループに属するかが int で入っているリスト",
				"\tReturns:",
					"\t\tDAG (list): DAG[k] にはグループ番号 k から辺が伸びているグループの番号の set が入っているリスト",
					"\t\tstrongly_connected (list): strongly_connected[k] にはグループ番号 k の強連結成分内の頂点のリストが入っているリスト",
				"\t'''",
				"\tn = len(graph)  ",
				"\tDAG = [set() for _ in range(group_num)]",
				"\tstrongly_connected = [[] for _ in range(group_num)]",
				"\tfor u in range(n):",
					"\t\tfor v in graph[u]:",
						"\t\t\tif vertex_to_group_num[u] != vertex_to_group_num[v]:",
							"\t\t\t\tDAG[vertex_to_group_num[u]].add(vertex_to_group_num[v])",
						"\t\t\telse:",
							"\t\t\t\tstrongly_connected[vertex_to_group_num[u]].append(v)",
				"\treturn DAG, strongly_connected"
		],
		"description": "strongly-connected components decomposition"
	},
	"Topological Sort": {
		"prefix": "topological_snippet",
		"body": [
			"from collections import deque",
			"",
			"def topological_bfs(adj):",
				"\t'''",
				"\tグラフをトポロジカルソートしたときの頂点の並び順を表すリストを返す。この長さが頂点数に一致しない場合は閉路あり。",
				"\tArgs:",
					"\t\tadj (list): 隣接リスト",
				"\tReturns:",
					"\t\tsorted_vertice (list): 有向グラフをトポロジカルソートしたときの頂点の並び順を表すリスト",
				"\t'''",
				"\tn = len(adj)",
				"\tdimensions = [0] * n",
				"\tfor edge in adj:",
					"\t\tfor v in edge:",
						"\t\t\tdimensions[v] += 1",
				"\tq = deque()",
				"\tfor i, dim in enumerate(dimensions):",
					"\t\tif dim == 0:",
						"\t\t\tq.append(i)",
				"\tsorted_vertice = []",
				"\t# BFS",
				"\twhile q:",
					"\t\ttop = q.popleft()",
					"\t\tif dimensions[top] != 0:",
						"\t\t\tbreak",
					"\t\tsorted_vertice.append(top)",
					"\t\tfor v in adj[top]:",
						"\t\t\tdimensions[v] -= 1",
						"\t\t\tif dimensions[v] == 0:",
							"\t\t\t\tq.append(v)",
				"\treturn sorted_vertice"
		],
		"description": "topological sort using BFS"
	},
	"Diameter of Tree": {
		"prefix": "diameter_of_tree_snippet",
		"body": [
			"def diameter_of_tree(adj, root):",
				"\tmax_dist = 0",
				"\tmost_remote_point = -1",
				"\tdef dfs(u, previous=None, dist=0):",
					"\t\tnonlocal max_dist",
					"\t\tnonlocal most_remote_point",
					"\t\tif max_dist < dist:",
						"\t\t\tmax_dist = dist",
						"\t\t\tmost_remote_point = u",
					"\t\tfor v in adj[u]:",
						"\t\t\t# 木の場合は visited 判定がいらない。自分自身を探索範囲から除けばそれらは全て未探索である。",
						"\t\t\tif v != previous:",
							"\t\t\t\tdfs(v, previous=u, dist=dist+1)",
				"\tdfs(root)",
				"\tmax_dist = 0",
				"\tend_point_1 = most_remote_point",
				"\tdfs(most_remote_point)",
				"\treturn (end_point_1, most_remote_point), max_dist"            
		],
		"description": "diameter of tree"
	},
	"Bipartite graph predicate": {
		"prefix": "bipartite_snippet",
		"body": [
			"def bipartite_predicate(adj):",
				"\tn = len(adj)",
				"\tstart = 0",
				"\tcolor = [None] * n",
				"\tcolor[start] = True",
				"\tstack = [start]",
				"\twhile stack:",
					"\t\tu = stack.pop()",
					"\t\tfor v in adj[u]:",
						"\t\t\tif color[v] is None:",
							"\t\t\t\tcolor[v] = not color[u]",
							"\t\t\t\tstack.append(v)",
						"\t\t\telif color[v] == color[u]:",
							"\t\t\t\treturn False",
				"\treturn True"            
		],
		"description": "bipartite graph predicate"
	},
	"Least Common Ancestor of Tree": {
		"prefix": "LCA_of_tree_snippet",
		"body": [
			"from math import log2",
			"class Node:",
				"\tdef __init__(self, val, dist_from_root=0, parent=None, children=[]):",
					"\t\tself.data = val",
					"\t\tself.dist_from_root = dist_from_root",
					"\t\tself.ancestors = [parent] if parent else []    # デフォルト値 (None) の時は [] となる",
					"\t\tassert(isinstance(children, list))",
					"\t\tself.children = children   # デフォルト値の時は [] になる",
				"\t",
				"\tdef kth_ancestor(self, k):",
					"\t\t'''",
					"\t\tk 個先の祖先の Node を返す",
					"\t\tancestors は [2^0個先の祖先, 2^1個先の祖先, ..., 2^lgn個先の祖先] が記録されているので一番探索区間を縮められるものを選択し、再帰的に探索する。",
					"\t\tArgs:",
						"\t\t\tk (int)",
					"\t\tReturns:",
						"\t\t\tNode",
					"\t\t'''",
					"\t\tif k == 0:",
						"\t\t\treturn self",
					"\t\tif self == NIL:",
						"\t\t\treturn NIL",
					"\t\tpower_of_two = int(log2(k))",
					"\t\tind = min(len(self.ancestors) - 1, power_of_two)",
					"\t\treturn self.ancestors[ind].kth_ancestor(k - pow(2, ind))",
			"",
			"",
			"NIL = Node(None)",
			"NIL.ancestors = [NIL]",
			"NIL.children = [NIL]",
			"",
			"",
			"class Tree:",
				"\tdef __init__(self, root, size):",
					"\t\tself.root = root",
					"\t\tself.size = size",
			"",
				"\tdef doubling_ancestors(self):",
					"\t\t'''",
					"\t\t(ダブリング) 全ノードに対し 2^i 個先の祖先を .ancestors[i] に記録していく O(n) * O(lgn)",
					"\t\t'''",
					"\t\tfor i in range(1, int(log2(self.size))+1):",
						"\t\t\tstack = [self.root]",
						"\t\t\twhile stack:",
							"\t\t\t\tu = stack.pop()",
							"\t\t\t\tu.ancestors.append(u.kth_ancestor(pow(2, i)))",
							"\t\t\t\tfor child in u.children:",
								"\t\t\t\t\tif child != NIL:",
									"\t\t\t\t\t\tstack.append(child)",
				"\t",
				"\tdef memorizing_dist(self, current_node=None, dist=0):",
					"\t\t'''",
					"\t\t(距離の記録) 全ノードに対し root からの距離を .dist_from_root に記録していく O(n)",
					"\t\tArgs:",
						"\t\t\tcurrent_node (Node): 再帰の時にこれを現在のノードに指定する。ユーザーが呼び出す時は指定しない。(デフォルト値の時は current_node が self.root になってくれる)   ",
						"\t\t\tdist (int): 再帰の時にこれを現在の root からの距離に指定する。ユーザーが呼び出す時は指定しない。(デフォルト値の時は current_node が self.root になってくれる)  ",
					"\t\t'''",
					"\t\tif current_node is None and dist == 0:",
						"\t\t\tcurrent_node = self.root",
					"\t\tcurrent_node.dist_from_root = dist",
					"\t\tfor child in current_node.children:",
						"\t\t\tif child != NIL:",
							"\t\t\t\tself.memorizing_dist(current_node=child, dist=dist+1)",
			"",
			"",
			"",
			"def calc_LCA(u, v):",
				"\t'''",
				"\t2 つの node を受け取り、その最小共通祖先を求める。(O(lgn))",
				"\tなお、各ノードのルートからの距離と k 祖先は計算ずみであるとする。",
				"\tArgs:",
					"\t\tu (Node)",
					"\t\tv (Node)",
				"\tReturns:",
					"\t\tNode",
				"\t'''",
				"\t# u は v と同じ深さかより深いノードとする",
				"\tif u.dist_from_root < v.dist_from_root:",
					"\t\tu, v = v, u",
				"\tdiff = u.dist_from_root - v.dist_from_root",
				"\tu1 = u.kth_ancestor(diff)",
				"\tv1 = v",
				"\t# そもそも同じ枝上に乗っていた場合",
				"\tif u1 == v1:",
					"\t\treturn u1",
				"\t# 別の枝に乗っていた場合",
				"\twhile u1.ancestors[0] != v1.ancestors[0]:",
					"\t\tassert(len(u1.ancestors) == len(v1.ancestors))",
					"\t\tn = len(u1.ancestors)",
					"\t\tfor i in range(n):",
						"\t\t\tif u1.ancestors[i] == v1.ancestors[i]:",
							"\t\t\t\t# 合流せず遡れるギリギリまで遡る",
							"\t\t\t\tu1 = u1.ancestors[i-1]",
							"\t\t\t\tv1 = v1.ancestors[i-1]",
							"\t\t\t\tbreak",
				"\treturn u1.ancestors[0]"            
		],
		"description": "least common ancestor of tree"
	},
	"Bellman Ford": {
		"prefix": "bellman_snippet",
		"body": [
			"class NegativeLoopError(Exception):",
				"\tpass",
			"",
			"",
			"class Edge:",
				"\tdef __init__(self, here, to, weight):",
					"\t\tself.here = here",
					"\t\tself.to = to",
					"\t\tself.weight = weight",
			"",
			"",
			"",
			"def bellman(edges, start=0):",
				"\t'''",
				"\tstart から全頂点までの最短コストを計算して返す。辿り着けぬ場合は inf が出力される。(O(V * E))",
				"\t負サイクルがある場合 NegativeLoopError があげられる",
				"\t'''",
				"\t# E = len(edges)",
				"\tV = max(map(lambda x: max(x.here, x.to), edges)) + 1    # 0 to この値なので",
				"\tcost = [float('inf')] * V",
				"\tcost[start] = 0",
				"\tupdated = True",
				"\ti = 1",
				"\twhile i <= V and updated:",
					"\t\tupdated = False",
					"\t\tfor e in edges:",
						"\t\t\tpossible_value = cost[e.here]+e.weight",
						"\t\t\tif cost[e.to] > possible_value:",
							"\t\t\t\tcost[e.to] = possible_value",
							"\t\t\t\tupdated = True",
					"\t\ti += 1",
				"\tif i == V:",
					"\t\traise NegativeLoopError",
				"\telse:",
					"\t\treturn cost"            
		],
		"description": "shortest path (bellman ford)"
	},
	"Dijkstra": {
		"prefix": "dijkstra_snippet",
		"body": [
			"from heapq import heappush, heappop",
			"class PQueueMin:",
				"\tdef __init__(self):",
					"\t\tself.pq = []    # 第一要素に cost、第二要素に ind が来る様にする",
				"\t",
				"\tdef push(self, ind, cost):",
					"\t\theappush(self.pq, [cost, ind])",
				"\t",
				"\tdef pop(self):",
					"\t\tcost, ind = heappop(self.pq)",
					"\t\treturn [ind, cost]",
			"",
				"\tdef is_empty(self):",
					"\t\treturn len(self.pq)==0",
			"",
			"",
			"",
			"def dijkstra(adj_with_weight, start=0):",
				"\t'''",
				"\tDijkstra 法 O((E+V)lgV) (頂点を回るときに最小のものを取り出していくのに VlgV, cost の更新で ElgV)",
				"\t負辺を含まぬ重みつきグラフについて、ある頂点から他の頂点までの最短コストを貪欲に計算する",
				"\t'''",
				"\tV = len(adj_with_weight)",
				"\tcost = [float('inf')] * V",
				"\tcost[start] = 0",
				"\tfixed = [False] * V",
				"\tpq = PQueueMin()",
				"\t# 最初は始点が必ずコスト最小。pq に突っ込む",
				"\tpq.push(start, cost[start])",
				"\twhile not pq.is_empty():",
					"\t\t# 現段階で最短のコストとなっている頂点を選択",
					"\t\tu, cost_of_u = pq.pop()",
					"\t\tfixed[u] = True",
					"\t\tfor v, weight_of_uv in adj_with_weight[u]:",
						"\t\t\tif not fixed[v] and cost[v] > cost_of_u + weight_of_uv:",
							"\t\t\t\tcost[v] = cost_of_u + weight_of_uv",
							"\t\t\t\tpq.push(v, cost[v])",
				"\treturn cost"            
		],
		"description": "dijkstra"
	},
	"Warshall Floyd": {
		"prefix": "warshall_snippet",
		"body": [
			"from copy import deepcopy",
			"",
			"def warshall_floyd(adj_mat_with_weight):",
				"\t'''",
				"\tWarshall-Floyd 法 (O(V^3), 1 sec だと v~500 とかが限界)",
				"\t全点対間の最短経路を三次元 DP で求める",
				"\tArgs:",
					"\t\tadj_mat_with_weight (list): 重みを記録した隣接行列 (非接続頂点は inf)",
				"\tReturns:",
					"\t\tdp (list): dp[i][j] を見れば全頂点を使用可能な時の i j 最短距離がわかる。最後に dp[i][i] が負になっていたら負サイクルが存在するということ",
				"\t'''",
				"\tV = len(adj_mat_with_weight)",
				"\t# テーブル初期化",
				"\tdp = deepcopy(adj_mat_with_weight)",
				"\tfor i in range(V):",
					"\t\tdp[i][i] = 0",
				"\t# 漸化式を解く",
				"\tfor k in range(1, V+1):",
					"\t\tfor i in range(V):",
						"\t\t\tfor j in range(V):",
							"\t\t\t\t# new 2d-table # old 2d-table",
							"\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][k-1]+dp[k-1][j])",
				"\treturn dp"            
		],
		"description": "shortest path between all points (warshall floyd"
	},
	"Kruskal MST": {
		"prefix": "Kruskal_snippet",
		"body": [
			"def kruskal(adj):",
				"\tn = len(adj)",
				"\tuf = UnionFindTree(n)",
				"\tedges = []",
				"\ttotal_cost = 0",
				"\tfor i, e in enumerate(adj):",
					"\t\tfor j, weight in e:",
						"\t\t\tif i <= j:",
							"\t\t\t\tedges.append((i, j, weight))",
				"\tedges.sort(key=lambda x: x[2])",
				"\tfor edge in edges:",
					"\t\tu, v, weight = edge",
					"\t\tif uf.union(u, v):",
						"\t\t\ttotal_cost += weight",
				"\treturn total_cost"            
		],
		"description": "Kruskal MST using Union Find Tree"
	},
	"DFS_traverse": {
		"prefix": "DFS_traverse_snippet",
		"body": [
			"visited = [False] * len(adjacent_list)",
			"elapsed_time = 0",
			"time_stamp = [[0, 0] for _ in range(len(adjacent_list))]    # [first_visited, finished_visiting]",
			"",
			"def dfs_recursive_traverse(u, recursive=False):",
				"\t''' ",
				"\t再帰を用いた DFS で全頂点を訪問する。最初に訪れた時間と、その頂点からの隣接頂点を全てコンプリートした時間を記録する。",
				"\t隣接リストを用いた実装なので、初期化に O(v) + 辺の探索に O(E) で O(V+E)",
				"\t訪問が目的なので「過去一度でもその頂点を訪問したか」に注目する。",
				"\t第一引数 u が現在地を表し、関数呼び出しがその頂点へ進むことと対応する。",
				"\t'''",
				"\tglobal elapsed_time",
				"\t# 初期化",
				"\tif not recursive:",
					"\t\tfor i in range(len(adjacent_list)):",
						"\t\t\telapsed_time = 0",
						"\t\t\tvisited[i] = False",
						"\t\t\ttime_stamp[i][0] = 0",
						"\t\t\ttime_stamp[i][0] = 0",
				"\t# 彩色をし、タイムスタンプを押す",
				"\tvisited[u] = True",
				"\telapsed_time += 1",
				"\ttime_stamp[u][0] = elapsed_time",
				"\tprint(f'({u}', end=' ')    # 訪れたときの出力",
				"\tfor v in adjacent_list[u]:",
					"\t\tif not visited[v]:",
						"\t\t\tdfs_recursive_traverse(v, recursive=True)    # その頂点へ進む -> その頂点の隣接頂点が周り済みになると戻ってくる。  ",
				"\t# タイムスタンプを押す",
				"\telapsed_time += 1",
				"\ttime_stamp[u][1] = elapsed_time",
				"\tprint(f'{u})', end=' ')    # 訪れたときの出力"
		],
		"description": "DFS traverse using recursion"
	},
	"BFS traverse": {
		"prefix": "BFS_traverse_snippet",
		"body": [
			"from collections import deque",
			"",
			"visited = [False] * len(adjacent_list)",
			"",
			"def bfs_queue_traverse(u):",
				"\t# 初期化",
				"\tfor i in range(len(adjacent_list)):",
					"\t\tvisited[i] = False",
				"\tqueue = deque([u])",
				"\twhile queue:",
					"\t\tcurrent = queue.popleft()",
					"\t\tif not visited[current]:",
						"\t\t\tvisited[current] = True",
						"\t\t\tfor v in adjacent_list[current]:",
							"\t\t\t\tif not visited[v]:",
								"\t\t\t\t\tqueue.append(v)"
		],
		"description": "BFS traverse using queue"
	},
	"kD tree (1D)": {
		"prefix": "kD_1D",
		"body": [
			"class OneDimNode:",
				"\tdef __init__(self, x=None, parent=None, left=None, right=None):",
					"\t\t'''",
					"\t\t1 次元二分探索木のためのノード",
					"\t\t'''",
					"\t\tself.x = x",
					"\t\tself.parent = parent",
					"\t\tself.left = left",
					"\t\tself.right = right",
					"\t\tself.flag = True",
			"",
			"class OneDimTree:",
				"\tdef __init__(self, points=[]):",
					"\t\t'''",
					"\t\t1 次元二分探索木 (kD tree) を作成する",
					"\t\t'''",
					"\t\t# nil の設定",
					"\t\tself.nil = OneDimNode()",
					"\t\tself.nil.parent = self.nil",
					"\t\tself.nil.left = self.nil",
					"\t\tself.nil.right = self.nil",
					"\t\t# root の設定",
					"\t\tself.root = self.nil",
					"\t\t# もし予め一次元の点の集合が与えられるのならバランスする形で kD tree を構築する",
					"\t\tself._balance_insert(sorted(points))",
				"\t",
				"\tdef _balance_insert(self, seq):",
					"\t\t# seq はソートずみであるとする (1 次元の場合ソートするキーを変える必要がないので 1 回ですむ)",
					"\t\t# 毎回中央値をとって insert すれば平衡になる",
					"\t\tif seq:",
						"\t\t\tmid = len(seq) // 2",
						"\t\t\tself.insert(seq[mid])",
						"\t\t\tself._balance_insert(seq[:mid])",
						"\t\t\tself._balance_insert(seq[mid+1:])",
			"",
				"\t",
				"\tdef traverse(self, node=None):",
					"\t\tnode = self.root if node is None else node",
					"\t\tif node != self.nil:",
						"\t\t\tself.traverse(node=node.left)",
						"\t\t\tprint(node.x, end=' ')",
						"\t\t\tself.traverse(node=node.right)",
					"\t\t",
				"\tdef insert(self, x):",
					"\t\t'''",
					"\t\tkD tree に値が x であるノードを O(depth) で挿入する",
					"\t\t(コンストラクタで生成した kD tree は平衡であることが保証されるが、insert により生成した部分の平衡性は保証されないことに注意)",
					"\t\t'''",
					"\t\ttrailer = self.nil    # x を挿入するべき nil の一つ前のノードを保存するトレーラポインタ",
					"\t\tpos = self.root    # x を挿入するべき nil の場所を探す",
					"\t\twhile pos != self.nil:",
						"\t\t\ttrailer = pos",
						"\t\t\tif x < pos.x:",
							"\t\t\t\tpos = pos.left",
						"\t\t\telif pos.x < x:",
							"\t\t\t\tpos = pos.right",
						"\t\t\telse:",
							"\t\t\t\tpos.flag ^= pos.flag",
							"\t\t\t\tpos = pos.left if pos.flag else pos.right",
					"\t\tinserted_node = OneDimNode(x, trailer, self.nil, self.nil)",
					"\t\t# tree is empty",
					"\t\tif trailer == self.nil:",
						"\t\t\tself.root = inserted_node",
					"\t\t# どこかのノードの子供の位置に挿入する時",
					"\t\telif x < trailer.x or (x == trailer.x and trailer.flag):",
						"\t\t\ttrailer.left = inserted_node",
					"\t\telse:",
						"\t\t\ttrailer.right = inserted_node",
				"\t",
				"\tdef one_dim_search(self, sx, tx, node=None):",
					"\t\t'''",
					"\t\tkD tree に対し閉区間 [sx, tx] 内に存在する点を探してリストにまとめて返す (対応する点の個数 k として O(k))",
					"\t\t下記のように検索必要性を判断し再帰的に左右の子に対し探索を行えば良い",
			"",
					"\t\t<-------- node.x -------->",
					"\t\t<----------->",
					"\t\t少しでも [sx,tx] が左側ゾーン ((-inf, node.x]) に被っていたら検索しておく必要がある",
								"\t\t\t\t\t<----->",
								"\t\t\t\t\t少しでも [sx, tx] が右側ゾーン ([node.x, inf)) に被っていたら検索しておく必要がある",
					"\t\t'''",
					"\t\tbuf = []",
					"\t\tnode = self.root if node is None else node",
					"\t\tif node.left != self.nil and sx <= node.x:",
						"\t\t\tbuf += self.one_dim_search(sx, tx, node.left)",
					"\t\tif sx <= node.x <= tx:",
						"\t\t\tbuf.append(node.x)",
					"\t\tif node.right != self.nil and tx >= node.x:",
						"\t\t\tbuf += self.one_dim_search(sx, tx, node.right)",
					"\t\treturn buf"
		],
		"description": "kD tree (1D, aka range_search_tree)"
	},
	"kD tree (2D)": {
		"prefix": "kD_2D",
		"body": [
			"from operator import itemgetter",
			"class TwoDimNode:",
				"\tdef __init__(self, x=None, y=None, parent=None, left=None, right=None):",
					"\t\t'''",
					"\t\t2 次元二分探索木のためのノード",
					"\t\t'''        ",
					"\t\tself.x = x",
					"\t\tself.y = y",
					"\t\tself.parent = parent",
					"\t\tself.left = left",
					"\t\tself.right = right",
					"\t\tself.flag = True",
			"",
			"class TwoDimTree:",
				"\tdef __init__(self, points=[]):",
					"\t\t'''",
					"\t\t2 次元二分探索木 (kD tree) を作成する",
					"\t\troot の深さを 0 として、深さが偶数の場合そこでは x を基準に、奇数の場合 y を基準に二分探索木条件を満たすようにする",
					"\t\t'''",
					"\t\t# nil の設定",
					"\t\tself.nil = TwoDimNode()",
					"\t\tself.nil.parent = self.nil",
					"\t\tself.nil.left = self.nil",
					"\t\tself.nil.right = self.nil",
					"\t\t# root の設定",
					"\t\tself.root = self.nil",
					"\t\t# もし予め一次元の点の集合が与えられるのならバランスする形で kD tree を構築する",
					"\t\tself._balance_insert(points)",
				"\t",
				"\tdef preorder_traverse(self, node=None):",
					"\t\tnode = self.root if node is None else node",
					"\t\tif node != self.nil:",
						"\t\t\tprint(f'({node.x},{node.y})', end=' ')",
						"\t\t\tself.preorder_traverse(node=node.left)",
						"\t\t\tself.preorder_traverse(node=node.right)",
					"\t\t",
				"\tdef postorder_traverse(self, node=None):",
					"\t\tnode = self.root if node is None else node",
					"\t\tif node != self.nil:",
						"\t\t\tself.preorder_traverse(node=node.left)",
						"\t\t\tself.preorder_traverse(node=node.right)",
						"\t\t\tprint(f'({node.x},{node.y})', end=' ')",
			"",
				"\tdef inorder_traverse(self, node=None):",
					"\t\tnode = self.root if node is None else node",
					"\t\tif node != self.nil:",
						"\t\t\tself.preorder_traverse(node=node.left)",
						"\t\t\tprint(f'({node.x},{node.y})', end=' ')",
						"\t\t\tself.preorder_traverse(node=node.right)",
				"\t",
				"\tdef _balance_insert(self, seq, depth=0):",
					"\t\t# 毎回 x or y をキーとしてソートを行い、中央値をとって insert すれば平衡になる",
					"\t\tif seq:",
						"\t\t\tarranged = sorted(seq, key=itemgetter(depth % 2))",
						"\t\t\tmid = len(seq) // 2",
						"\t\t\tself.insert(seq[mid][0], seq[mid][1])",
						"\t\t\tself._balance_insert(arranged[:mid], depth+1)",
						"\t\t\tself._balance_insert(arranged[mid+1:], depth+1)",
			"",
			"",
				"\tdef insert(self, x, y):",
					"\t\t'''",
					"\t\tkD tree に値が (x, y) であるノードを O(depth) で挿入する",
					"\t\t(コンストラクタで生成した kD tree は平衡であることが保証されるが、insert により生成した部分の平衡性は保証されないことに注意)        ",
					"\t\t'''",
					"\t\ttrailer = self.nil    # (x, y) を挿入するべき nil の一つ前のノードを保存するトレーラポインタ",
					"\t\tpos = self.root    # (x, y) を挿入するべき nil の場所を探す",
					"\t\tdepth = 0",
					"\t\twhile pos != self.nil:",
						"\t\t\ttrailer = pos",
						"\t\t\tk, pos_k = (x, pos.x) if depth % 2 == 0 else (y, pos.y)",
						"\t\t\tif k < pos_k:",
							"\t\t\t\tpos = pos.left",
						"\t\t\telif pos_k < k:",
							"\t\t\t\tpos = pos.right",
						"\t\t\telse:",
							"\t\t\t\tpos.flag ^= pos.flag",
							"\t\t\t\tpos = pos.left if pos.flag else pos.right",
						"\t\t\tdepth += 1",
					"\t\tinserted_node = TwoDimNode(x, y, trailer, self.nil, self.nil)",
					"\t\t# trailer の depth",
					"\t\tdepth -= 1",
					"\t\tk, trailer_k = (x, trailer.x) if depth % 2 == 0 else (y, trailer.y)",
					"\t\t# tree is empty",
					"\t\tif trailer == self.nil:",
						"\t\t\tself.root = inserted_node",
					"\t\t# どこかのノードの子供の位置に挿入する時",
					"\t\telif k < trailer_k or (k == trailer_k and trailer.flag):",
						"\t\t\ttrailer.left = inserted_node",
					"\t\telse:",
						"\t\t\ttrailer.right = inserted_node",
				"\t",
				"\tdef two_dim_search(self, sx, tx, sy, ty, node=None, depth=0):",
					"\t\t'''",
					"\t\tkD tree に対し閉区間 D = {(x, y) | sx<=x<=tx, sy<=y<=ty} 内に存在する点を探してリストにまとめて返す (対応する点の個数 k として O(√n + k))",
					"\t\t下記のように検索必要性を判断し再帰的に左右の子に対し探索を行えば良い",
			"",
					"\t\t<-------- node.x -------->",
					   "\t\t<----------->",
					  "\t\t少しでも [sx,tx] が左側ゾーン ((-inf, node.x]) に被っていたら検索しておく必要がある",
								  "\t\t\t\t\t<----->",
								  "\t\t\t\t\t少しでも [sx, tx] が右側ゾーン ([node.x, inf)) に被っていたら検索しておく必要がある",
					"\t\t'''        ",
					"\t\tbuf = []",
					"\t\tnode = self.root if node is None else node",
					"\t\t# print(f'{node.x} {node.y}')",
					"\t\tif depth % 2 == 0:",
						"\t\t\tif node.left != self.nil and sx <= node.x:",
							"\t\t\t\tbuf += self.two_dim_search(sx, tx, sy, ty, node.left, depth+1)",
						"\t\t\tif sx <= node.x <= tx and sy <= node.y <= ty:",
							"\t\t\t\tbuf.append((node.x, node.y))",
						"\t\t\tif node.right != self.nil and tx >= node.x:",
							"\t\t\t\tbuf += self.two_dim_search(sx, tx, sy, ty, node.right, depth+1)",
					"\t\telse:",
						"\t\t\tif node.left != self.nil and sy <= node.y:",
							"\t\t\t\tbuf += self.two_dim_search(sx, tx, sy, ty, node.left, depth+1)",
						"\t\t\tif sx <= node.x <= tx and sy <= node.y <= ty:",
							"\t\t\t\tbuf.append((node.x, node.y))",
						"\t\t\tif node.right != self.nil and ty >= node.y:",
							"\t\t\t\tbuf += self.two_dim_search(sx, tx, sy, ty, node.right, depth+1)",
					"\t\treturn buf"
		],
		"description": "kD tree (2D, aka range_search_tree)"
	}
}
